import {
  Route_default,
  Y,
  f
} from "./chunk-U4REFAVU.js";
import "./chunk-AYNHEKRI.js";
import {
  writable
} from "./chunk-TQADDRNY.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  append_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  compute_rest_props,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  flush,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_update,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-H7EXK5L6.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-KVCYZR2Q.js";

// node_modules/kie-ui-kit/src/components/test.svelte
import logo from "/Users/rajeshazmeera/works/krafton/UI-KIT-TEST/node_modules/kie-ui-kit/src/assets/images/bgmi-logo1.png";
var file = "node_modules/kie-ui-kit/src/components/test.svelte";
function add_css(target) {
  append_styles(target, "svelte-1dc5p9", ".banner.svelte-1dc5p9{max-width:400px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBY0ksc0JBQ0UsZUFDRiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsidGVzdC5zdmVsdGUiXX0= */");
}
function create_fragment(ctx) {
  let div;
  let img;
  let img_src_value;
  let t0;
  let h1;
  let t1;
  let t2;
  let p;
  let t3;
  const block = {
    c: function create2() {
      div = element("div");
      img = element("img");
      t0 = space();
      h1 = element("h1");
      t1 = text(
        /*title*/
        ctx[0]
      );
      t2 = space();
      p = element("p");
      t3 = text(
        /*description*/
        ctx[1]
      );
      if (!src_url_equal(img.src, img_src_value = logo)) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Logo");
      attr_dev(img, "class", "w-16 h-16 mb-4");
      add_location(img, file, 8, 4, 371);
      attr_dev(h1, "class", "text-2xl font-bold");
      add_location(h1, file, 9, 4, 430);
      attr_dev(p, "class", "mt-2");
      add_location(p, file, 10, 4, 478);
      attr_dev(div, "class", "banner bg-cover bg-center text-white p-8 rounded-lg shadow-lg svelte-1dc5p9");
      set_style(div, "background-image", "url('../assets/images/recent-hero.jpg')");
      add_location(div, file, 7, 2, 224);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, img);
      append_dev(div, t0);
      append_dev(div, h1);
      append_dev(h1, t1);
      append_dev(div, t2);
      append_dev(div, p);
      append_dev(p, t3);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*title*/
      1) set_data_dev(
        t1,
        /*title*/
        ctx2[0]
      );
      if (dirty & /*description*/
      2) set_data_dev(
        t3,
        /*description*/
        ctx2[1]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Test", slots, []);
  let { title = "Welcome!" } = $$props;
  let { description = "This is a reusable banner component." } = $$props;
  const writable_props = ["title", "description"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Test> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2) $$invalidate(1, description = $$props2.description);
  };
  $$self.$capture_state = () => ({ title, description, logo });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("description" in $$props2) $$invalidate(1, description = $$props2.description);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, description];
}
var Test = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { title: 0, description: 1 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Test",
      options,
      id: create_fragment.name
    });
  }
  get title() {
    throw new Error("<Test>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Test>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<Test>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<Test>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var test_default = Test;

// node_modules/kie-ui-kit/src/components/test1.svelte
var file2 = "node_modules/kie-ui-kit/src/components/test1.svelte";
function create_fragment2(ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      t = text("test 1 component \n    ");
      if (default_slot) default_slot.c();
      add_location(div, file2, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Test1", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Test1> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Test1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Test1",
      options,
      id: create_fragment2.name
    });
  }
};
var test1_default = Test1;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/components/Section.svelte
var file3 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/components/Section.svelte";
function create_fragment3(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create2() {
      div = element("div");
      if (default_slot) default_slot.c();
      attr_dev(div, "class", "mx-auto max-w-[1920px] px-5 sm:px-6 md:px-16 lg:px-32 ");
      add_location(div, file3, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Section", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Section> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Section = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Section",
      options,
      id: create_fragment3.name
    });
  }
};
var Section_default = Section;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Pages/ActiveTournaments/LeaderBorad.svelte
var file4 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Pages/ActiveTournaments/LeaderBorad.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  child_ctx[3] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block_2(ctx) {
  let div1;
  let select;
  let option;
  let t1;
  let div0;
  let svg;
  let path;
  let t2;
  const block = {
    c: function create2() {
      div1 = element("div");
      select = element("select");
      option = element("option");
      option.textContent = `${/*filter*/
      ctx[7]}`;
      t1 = space();
      div0 = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      t2 = space();
      option.__value = "";
      set_input_value(option, option.__value);
      add_location(option, file4, 26, 22, 1928);
      attr_dev(select, "class", "appearance-none pl-4 rounded-md shadow border border-Charcoal/300 py-2 bg-Charcoal/400 text-Charcoal/100 text-xs sm:text-sm font-medium leading-tight border-none focus:ring-0 focus:outline-none pr-8 w-full sm:w-auto");
      add_location(select, file4, 24, 18, 1650);
      attr_dev(path, "stroke-linecap", "round");
      attr_dev(path, "stroke-linejoin", "round");
      attr_dev(path, "stroke-width", "2");
      attr_dev(path, "d", "M19 9l-7 7-7-7");
      add_location(path, file4, 31, 26, 2263);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "h-5 w-5 text-Charcoal/100");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      add_location(svg, file4, 29, 22, 2082);
      attr_dev(div0, "class", "pointer-events-none absolute right-3");
      add_location(div0, file4, 28, 18, 2009);
      attr_dev(div1, "class", "justify-center items-center gap-2 flex relative w-full sm:w-auto");
      add_location(div1, file4, 22, 14, 1534);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, select);
      append_dev(select, option);
      append_dev(div1, t1);
      append_dev(div1, div0);
      append_dev(div0, svg);
      append_dev(svg, path);
      append_dev(div1, t2);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: '(22:14) {#each [\\"Round\\", \\"Day\\", \\"Group\\"] as filter}',
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let th;
  const block = {
    c: function create2() {
      th = element("th");
      th.textContent = `${/*header*/
      ctx[4]}`;
      attr_dev(th, "class", "px-6 py-3 bg-Charcoal/900 text-yellow-400 text-xs font-medium uppercase leading-none tracking-wide text-left");
      add_location(th, file4, 42, 26, 2856);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: '(42:26) {#each [\\"RANK\\", \\"TEAM NAME\\", \\"GROUP\\", \\"DAMAGE\\", \\"FIN.PTS\\", \\"POS.PTS\\", \\"TOT.PTS \\"] as header}',
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let tr;
  let td0;
  let t1;
  let td1;
  let img;
  let img_src_value;
  let t2;
  let span;
  let t4;
  let td2;
  let t6;
  let td3;
  let t8;
  let td4;
  let t10;
  let td5;
  let t12;
  let td6;
  let t14;
  let tr_class_value;
  const block = {
    c: function create2() {
      tr = element("tr");
      td0 = element("td");
      td0.textContent = `${/*row*/
      ctx[1].id}`;
      t1 = space();
      td1 = element("td");
      img = element("img");
      t2 = space();
      span = element("span");
      span.textContent = `${/*row*/
      ctx[1].inGameName}`;
      t4 = space();
      td2 = element("td");
      td2.textContent = `${/*row*/
      ctx[1].Group}`;
      t6 = space();
      td3 = element("td");
      td3.textContent = `${/*row*/
      ctx[1].Damage}`;
      t8 = space();
      td4 = element("td");
      td4.textContent = `${/*row*/
      ctx[1].time}`;
      t10 = space();
      td5 = element("td");
      td5.textContent = `${/*row*/
      ctx[1].position}`;
      t12 = space();
      td6 = element("td");
      td6.textContent = `${/*row*/
      ctx[1].overall}`;
      t14 = space();
      attr_dev(td0, "class", "px-6 py-5 text-Charcoal/50 text-sm font-medium leading-tight");
      add_location(td0, file4, 51, 26, 3366);
      attr_dev(img, "class", "rounded-xl inline-block mr-2");
      if (!src_url_equal(img.src, img_src_value = "/images/Avatar.png")) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "");
      add_location(img, file4, 53, 30, 3583);
      add_location(span, file4, 54, 30, 3690);
      attr_dev(td1, "class", "px-6 py-5 text-Charcoal/50 text-sm font-medium leading-tight");
      add_location(td1, file4, 52, 26, 3479);
      attr_dev(td2, "class", "px-6 py-5 text-Charcoal/100 text-sm font-normal");
      add_location(td2, file4, 56, 26, 3778);
      attr_dev(td3, "class", "px-6 py-5 text-Charcoal/100 text-sm font-normal");
      add_location(td3, file4, 57, 26, 3881);
      attr_dev(td4, "class", "px-6 py-5 text-Charcoal/100 text-sm font-normal");
      add_location(td4, file4, 58, 26, 3985);
      attr_dev(td5, "class", "px-6 py-5 text-Charcoal/100 text-sm font-normal");
      add_location(td5, file4, 59, 26, 4087);
      attr_dev(td6, "class", "px-6 py-5 text-Charcoal/100 text-sm font-normal");
      add_location(td6, file4, 60, 26, 4193);
      attr_dev(tr, "class", tr_class_value = `transition duration-300 ${/*index*/
      ctx[3] % 2 === 0 ? " bg-Charcoal/600" : " bg-Charcoal/500"}`);
      add_location(tr, file4, 50, 22, 3241);
    },
    m: function mount(target, anchor) {
      insert_dev(target, tr, anchor);
      append_dev(tr, td0);
      append_dev(tr, t1);
      append_dev(tr, td1);
      append_dev(td1, img);
      append_dev(td1, t2);
      append_dev(td1, span);
      append_dev(tr, t4);
      append_dev(tr, td2);
      append_dev(tr, t6);
      append_dev(tr, td3);
      append_dev(tr, t8);
      append_dev(tr, td4);
      append_dev(tr, t10);
      append_dev(tr, td5);
      append_dev(tr, t12);
      append_dev(tr, td6);
      append_dev(tr, t14);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(50:22) {#each players as row, index}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let div3;
  let div2;
  let div0;
  let t0;
  let div1;
  let table;
  let thead;
  let tr;
  let t1;
  let tbody;
  let each_value_2 = ensure_array_like_dev(["Round", "Day", "Group"]);
  let each_blocks_2 = [];
  for (let i = 0; i < 3; i += 1) {
    each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value_1 = ensure_array_like_dev(["RANK", "TEAM NAME", "GROUP", "DAMAGE", "FIN.PTS", "POS.PTS", "TOT.PTS "]);
  let each_blocks_1 = [];
  for (let i = 0; i < 7; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like_dev(
    /*players*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create2() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      for (let i = 0; i < 3; i += 1) {
        each_blocks_2[i].c();
      }
      t0 = space();
      div1 = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      for (let i = 0; i < 7; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div0, "class", "w-full justify-start items-center gap-2 sm:gap-3 inline-flex");
      add_location(div0, file4, 20, 10, 1387);
      add_location(tr, file4, 40, 22, 2706);
      add_location(thead, file4, 39, 18, 2676);
      add_location(tbody, file4, 48, 18, 3159);
      attr_dev(table, "class", "w-full border-collapse px-6");
      add_location(table, file4, 38, 14, 2614);
      attr_dev(div1, "class", "w-full flex-col justify-start items-start gap-4 md:gap-5 flex overflow-x-auto whitespace-nowrap rounded-md");
      add_location(div1, file4, 37, 10, 2479);
      attr_dev(div2, "class", "w-full sm:py-8 md:py-10 flex-col justify-start items-start gap-4 sm:gap-5 md:gap-6 lg:gap-7 inline-flex overflow-hidden ");
      add_location(div2, file4, 19, 6, 1242);
      attr_dev(div3, "class", "w-full py-6 bg-[#151515] flex-col justify-start items-start gap-7 inline-flex");
      add_location(div3, file4, 18, 4, 1143);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div2);
      append_dev(div2, div0);
      for (let i = 0; i < 3; i += 1) {
        if (each_blocks_2[i]) {
          each_blocks_2[i].m(div0, null);
        }
      }
      append_dev(div2, t0);
      append_dev(div2, div1);
      append_dev(div1, table);
      append_dev(table, thead);
      append_dev(thead, tr);
      for (let i = 0; i < 7; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(tr, null);
        }
      }
      append_dev(table, t1);
      append_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*players*/
      1) {
        each_value = ensure_array_like_dev(
          /*players*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      destroy_each(each_blocks_2, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(18:2) <Section>",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let section;
  let current;
  section = new Section_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(section.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const section_changes = {};
      if (dirty & /*$$scope*/
      1024) {
        section_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LeaderBorad", slots, []);
  let players = [
    {
      id: 1,
      inGameName: "Player1",
      fullName: "Full Name 1",
      totalPoints: 2e4,
      avgFinish: 95
    },
    {
      id: 2,
      inGameName: "Player2",
      fullName: "Full Name 2",
      totalPoints: 19e3,
      avgFinish: 90
    },
    {
      id: 2,
      inGameName: "Player2",
      fullName: "Full Name 2",
      totalPoints: 19e3,
      avgFinish: 90
    },
    {
      id: 2,
      inGameName: "Player2",
      fullName: "Full Name 2",
      totalPoints: 19e3,
      avgFinish: 90
    },
    {
      id: 2,
      inGameName: "Player2",
      fullName: "Full Name 2",
      totalPoints: 19e3,
      avgFinish: 90
    },
    {
      id: 2,
      inGameName: "Player2",
      fullName: "Full Name 2",
      totalPoints: 19e3,
      avgFinish: 90
    },
    {
      id: 2,
      inGameName: "Player2",
      fullName: "Full Name 2",
      totalPoints: 19e3,
      avgFinish: 90
    },
    {
      id: 2,
      inGameName: "Player2",
      fullName: "Full Name 2",
      totalPoints: 19e3,
      avgFinish: 90
    },
    {
      id: 2,
      inGameName: "Player2",
      fullName: "Full Name 2",
      totalPoints: 19e3,
      avgFinish: 90
    },
    {
      id: 2,
      inGameName: "Player2",
      fullName: "Full Name 2",
      totalPoints: 19e3,
      avgFinish: 90
    }
  ];
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<LeaderBorad> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ Section: Section_default, players });
  $$self.$inject_state = ($$props2) => {
    if ("players" in $$props2) $$invalidate(0, players = $$props2.players);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [players];
}
var LeaderBorad = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LeaderBorad",
      options,
      id: create_fragment4.name
    });
  }
};
var LeaderBorad_default = LeaderBorad;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/PrizePool.svelte
var file5 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/PrizePool.svelte";
function create_fragment5(ctx) {
  let div46;
  let div4;
  let img0;
  let img0_src_value;
  let t0;
  let div0;
  let t1;
  let div3;
  let div1;
  let t3;
  let div2;
  let t5;
  let img1;
  let img1_src_value;
  let t6;
  let div15;
  let div7;
  let div5;
  let t8;
  let div6;
  let t10;
  let div14;
  let div10;
  let div8;
  let t12;
  let div9;
  let t14;
  let div13;
  let div11;
  let t16;
  let div12;
  let t18;
  let div31;
  let div18;
  let div16;
  let t20;
  let div17;
  let t22;
  let div21;
  let div19;
  let t24;
  let div20;
  let t26;
  let div24;
  let div22;
  let t28;
  let div23;
  let t30;
  let div27;
  let div25;
  let t32;
  let div26;
  let t34;
  let div30;
  let div28;
  let t36;
  let div29;
  let t38;
  let div32;
  let t40;
  let div45;
  let div35;
  let div33;
  let t42;
  let div34;
  let t44;
  let div38;
  let div36;
  let t46;
  let div37;
  let t48;
  let div41;
  let div39;
  let t50;
  let div40;
  let t52;
  let div44;
  let div42;
  let t54;
  let div43;
  const block = {
    c: function create2() {
      div46 = element("div");
      div4 = element("div");
      img0 = element("img");
      t0 = space();
      div0 = element("div");
      t1 = space();
      div3 = element("div");
      div1 = element("div");
      div1.textContent = "TOTAL PRIZE POOL";
      t3 = space();
      div2 = element("div");
      div2.textContent = "₹2,00,00,000";
      t5 = space();
      img1 = element("img");
      t6 = space();
      div15 = element("div");
      div7 = element("div");
      div5 = element("div");
      div5.textContent = "1st Position";
      t8 = space();
      div6 = element("div");
      div6.textContent = "₹40,00,000";
      t10 = space();
      div14 = element("div");
      div10 = element("div");
      div8 = element("div");
      div8.textContent = "2nd Position";
      t12 = space();
      div9 = element("div");
      div9.textContent = "₹20,00,000";
      t14 = space();
      div13 = element("div");
      div11 = element("div");
      div11.textContent = "3rd Position";
      t16 = space();
      div12 = element("div");
      div12.textContent = "₹10,00,000";
      t18 = space();
      div31 = element("div");
      div18 = element("div");
      div16 = element("div");
      div16.textContent = "4th Position";
      t20 = space();
      div17 = element("div");
      div17.textContent = "₹5,00,000";
      t22 = space();
      div21 = element("div");
      div19 = element("div");
      div19.textContent = "5th & 6th";
      t24 = space();
      div20 = element("div");
      div20.textContent = "₹3,00,000";
      t26 = space();
      div24 = element("div");
      div22 = element("div");
      div22.textContent = "7th & 8th";
      t28 = space();
      div23 = element("div");
      div23.textContent = "₹2,00,000";
      t30 = space();
      div27 = element("div");
      div25 = element("div");
      div25.textContent = "9th - 12th";
      t32 = space();
      div26 = element("div");
      div26.textContent = "₹1,50,000";
      t34 = space();
      div30 = element("div");
      div28 = element("div");
      div28.textContent = "13th - 16th";
      t36 = space();
      div29 = element("div");
      div29.textContent = "₹1,00,000";
      t38 = space();
      div32 = element("div");
      div32.textContent = "Special Rewards";
      t40 = space();
      div45 = element("div");
      div35 = element("div");
      div33 = element("div");
      div33.textContent = "MVP";
      t42 = space();
      div34 = element("div");
      div34.textContent = "₹4,00,000";
      t44 = space();
      div38 = element("div");
      div36 = element("div");
      div36.textContent = "Best IGL";
      t46 = space();
      div37 = element("div");
      div37.textContent = "₹2,00,000";
      t48 = space();
      div41 = element("div");
      div39 = element("div");
      div39.textContent = "Emerging Star";
      t50 = space();
      div40 = element("div");
      div40.textContent = "₹1,00,000";
      t52 = space();
      div44 = element("div");
      div42 = element("div");
      div42.textContent = "Fan Favorite";
      t54 = space();
      div43 = element("div");
      div43.textContent = "₹50,000";
      if (!src_url_equal(img0.src, img0_src_value = "/images/image 38.png")) attr_dev(img0, "src", img0_src_value);
      attr_dev(img0, "alt", "");
      attr_dev(img0, "class", "absolute inset-0 w-full h-full object-cover rounded-lg");
      add_location(img0, file5, 3, 4, 184);
      attr_dev(div0, "class", "absolute inset-0 bg-black/40 rounded-lg");
      add_location(div0, file5, 4, 4, 291);
      attr_dev(div1, "class", "text-white text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div1, file5, 6, 6, 496);
      attr_dev(div2, "class", "text-white text-3xl md:text-7xl font-extrabold");
      add_location(div2, file5, 7, 6, 608);
      attr_dev(div3, "class", "absolute top-1/2 transform -translate-y-1/2 px-6 md:left-[42px] flex flex-col items-center md:items-start gap-1 md:gap-3");
      add_location(div3, file5, 5, 4, 355);
      attr_dev(img1, "class", "hidden md:block absolute top-0 right-0 ");
      if (!src_url_equal(img1.src, img1_src_value = "/images/helmet.png")) attr_dev(img1, "src", img1_src_value);
      attr_dev(img1, "alt", "");
      add_location(img1, file5, 9, 4, 702);
      attr_dev(div4, "class", "relative bg-white rounded-lg h-[104px] md:h-[210px]");
      add_location(div4, file5, 2, 2, 114);
      attr_dev(div5, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div5, file5, 16, 6, 1049);
      attr_dev(div6, "class", "text-white text-2xl md:text-5xl font-extrabold");
      add_location(div6, file5, 17, 6, 1161);
      attr_dev(div7, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left col-span-1");
      add_location(div7, file5, 15, 4, 934);
      attr_dev(div8, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div8, file5, 22, 8, 1485);
      attr_dev(div9, "class", "text-white text-2xl md:text-5xl font-extrabold");
      add_location(div9, file5, 23, 8, 1599);
      attr_dev(div10, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div10, file5, 21, 6, 1379);
      attr_dev(div11, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div11, file5, 26, 8, 1801);
      attr_dev(div12, "class", "text-white text-2xl md:text-5xl font-extrabold");
      add_location(div12, file5, 27, 8, 1915);
      attr_dev(div13, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div13, file5, 25, 6, 1695);
      attr_dev(div14, "class", "grid grid-cols-2 gap-5 col-span-1 md:col-span-2");
      add_location(div14, file5, 20, 4, 1311);
      attr_dev(div15, "class", "grid grid-cols-1 md:grid-cols-3 gap-5");
      add_location(div15, file5, 13, 2, 830);
      attr_dev(div16, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div16, file5, 35, 6, 2227);
      attr_dev(div17, "class", "text-white text-lg md:text-3xl font-extrabold");
      add_location(div17, file5, 36, 6, 2339);
      attr_dev(div18, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div18, file5, 34, 4, 2123);
      attr_dev(div19, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div19, file5, 39, 6, 2533);
      attr_dev(div20, "class", "text-white text-lg md:text-3xl font-extrabold");
      add_location(div20, file5, 40, 6, 2642);
      attr_dev(div21, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div21, file5, 38, 4, 2429);
      attr_dev(div22, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div22, file5, 43, 6, 2836);
      attr_dev(div23, "class", "text-white text-lg md:text-3xl font-extrabold");
      add_location(div23, file5, 44, 6, 2945);
      attr_dev(div24, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div24, file5, 42, 4, 2732);
      attr_dev(div25, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div25, file5, 47, 6, 3139);
      attr_dev(div26, "class", "text-white text-lg md:text-3xl font-extrabold");
      add_location(div26, file5, 48, 6, 3249);
      attr_dev(div27, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div27, file5, 46, 4, 3035);
      attr_dev(div28, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div28, file5, 51, 6, 3443);
      attr_dev(div29, "class", "text-white text-lg md:text-3xl font-extrabold");
      add_location(div29, file5, 52, 6, 3554);
      attr_dev(div30, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div30, file5, 50, 4, 3339);
      attr_dev(div31, "class", "grid grid-cols-2 md:grid-cols-5 gap-5");
      add_location(div31, file5, 33, 2, 2067);
      attr_dev(div32, "class", "text-amber-400 text-center text-base font-semibold uppercase tracking-wide mt-5");
      add_location(div32, file5, 57, 2, 3687);
      attr_dev(div33, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div33, file5, 60, 6, 3969);
      attr_dev(div34, "class", "text-white text-xl md:text-4xl font-extrabold");
      add_location(div34, file5, 61, 6, 4072);
      attr_dev(div35, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div35, file5, 59, 4, 3865);
      attr_dev(div36, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div36, file5, 64, 6, 4266);
      attr_dev(div37, "class", "text-white text-xl md:text-4xl font-extrabold");
      add_location(div37, file5, 65, 6, 4374);
      attr_dev(div38, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div38, file5, 63, 4, 4162);
      attr_dev(div39, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div39, file5, 68, 6, 4568);
      attr_dev(div40, "class", "text-white text-xl md:text-4xl font-extrabold");
      add_location(div40, file5, 69, 6, 4681);
      attr_dev(div41, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div41, file5, 67, 4, 4464);
      attr_dev(div42, "class", "text-[#888888] text-xs md:text-base font-semibold uppercase tracking-wide");
      add_location(div42, file5, 72, 6, 4875);
      attr_dev(div43, "class", "text-white text-xl md:text-4xl font-extrabold");
      add_location(div43, file5, 73, 6, 4987);
      attr_dev(div44, "class", "p-4 md:p-6 bg-[#151515] rounded-xl border border-[#1d1d1d] text-center md:text-left");
      add_location(div44, file5, 71, 4, 4771);
      attr_dev(div45, "class", "grid grid-cols-2 md:grid-cols-4 gap-5 mt-3");
      add_location(div45, file5, 58, 2, 3804);
      attr_dev(div46, "class", "bg-[#111111] py-10 md:py-20 px-6 md:px-32 flex flex-col gap-5");
      add_location(div46, file5, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div46, anchor);
      append_dev(div46, div4);
      append_dev(div4, img0);
      append_dev(div4, t0);
      append_dev(div4, div0);
      append_dev(div4, t1);
      append_dev(div4, div3);
      append_dev(div3, div1);
      append_dev(div3, t3);
      append_dev(div3, div2);
      append_dev(div4, t5);
      append_dev(div4, img1);
      append_dev(div46, t6);
      append_dev(div46, div15);
      append_dev(div15, div7);
      append_dev(div7, div5);
      append_dev(div7, t8);
      append_dev(div7, div6);
      append_dev(div15, t10);
      append_dev(div15, div14);
      append_dev(div14, div10);
      append_dev(div10, div8);
      append_dev(div10, t12);
      append_dev(div10, div9);
      append_dev(div14, t14);
      append_dev(div14, div13);
      append_dev(div13, div11);
      append_dev(div13, t16);
      append_dev(div13, div12);
      append_dev(div46, t18);
      append_dev(div46, div31);
      append_dev(div31, div18);
      append_dev(div18, div16);
      append_dev(div18, t20);
      append_dev(div18, div17);
      append_dev(div31, t22);
      append_dev(div31, div21);
      append_dev(div21, div19);
      append_dev(div21, t24);
      append_dev(div21, div20);
      append_dev(div31, t26);
      append_dev(div31, div24);
      append_dev(div24, div22);
      append_dev(div24, t28);
      append_dev(div24, div23);
      append_dev(div31, t30);
      append_dev(div31, div27);
      append_dev(div27, div25);
      append_dev(div27, t32);
      append_dev(div27, div26);
      append_dev(div31, t34);
      append_dev(div31, div30);
      append_dev(div30, div28);
      append_dev(div30, t36);
      append_dev(div30, div29);
      append_dev(div46, t38);
      append_dev(div46, div32);
      append_dev(div46, t40);
      append_dev(div46, div45);
      append_dev(div45, div35);
      append_dev(div35, div33);
      append_dev(div35, t42);
      append_dev(div35, div34);
      append_dev(div45, t44);
      append_dev(div45, div38);
      append_dev(div38, div36);
      append_dev(div38, t46);
      append_dev(div38, div37);
      append_dev(div45, t48);
      append_dev(div45, div41);
      append_dev(div41, div39);
      append_dev(div41, t50);
      append_dev(div41, div40);
      append_dev(div45, t52);
      append_dev(div45, div44);
      append_dev(div44, div42);
      append_dev(div44, t54);
      append_dev(div44, div43);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div46);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PrizePool", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PrizePool> was created with unknown prop '${key}'`);
  });
  return [];
}
var PrizePool = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PrizePool",
      options,
      id: create_fragment5.name
    });
  }
};
var PrizePool_default = PrizePool;

// node_modules/@splidejs/svelte-splide/utils/classNames/classNames.js
function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}

// node_modules/@splidejs/svelte-splide/utils/forOwn/forOwn.js
function forOwn(object, iteratee) {
  if (object) {
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key !== "__proto__") {
        if (iteratee(object[key], key) === false) {
          break;
        }
      }
    }
  }
  return object;
}

// node_modules/@splidejs/svelte-splide/utils/getSlides/getSlides.js
function getSlides(splide) {
  var _a;
  const children2 = (_a = splide.Components.Elements) == null ? void 0 : _a.list.children;
  return children2 && Array.prototype.slice.call(children2) || [];
}

// node_modules/@splidejs/svelte-splide/utils/isObject/isObject.js
function isObject(subject) {
  return subject !== null && typeof subject === "object";
}

// node_modules/@splidejs/svelte-splide/utils/isEqualDeep/isEqualDeep.js
function isEqualDeep(subject1, subject2) {
  if (Array.isArray(subject1) && Array.isArray(subject2)) {
    return subject1.length === subject2.length && !subject1.some((elm, index) => !isEqualDeep(elm, subject2[index]));
  }
  if (isObject(subject1) && isObject(subject2)) {
    const keys1 = Object.keys(subject1);
    const keys2 = Object.keys(subject2);
    return keys1.length === keys2.length && !keys1.some((key) => {
      return !Object.prototype.hasOwnProperty.call(subject2, key) || !isEqualDeep(subject1[key], subject2[key]);
    });
  }
  return subject1 === subject2;
}

// node_modules/@splidejs/svelte-splide/utils/isEqualShallow/isEqualShallow.js
function isEqualShallow(array1, array2) {
  return array1.length === array2.length && !array1.some((elm, index) => elm !== array2[index]);
}

// node_modules/@splidejs/svelte-splide/utils/merge/merge.js
function merge(object, source) {
  const merged = object;
  forOwn(source, (value, key) => {
    if (Array.isArray(value)) {
      merged[key] = value.slice();
    } else if (isObject(value)) {
      merged[key] = merge(isObject(merged[key]) ? merged[key] : {}, value);
    } else {
      merged[key] = value;
    }
  });
  return merged;
}

// node_modules/@splidejs/splide/dist/js/splide.esm.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var MEDIA_PREFERS_REDUCED_MOTION = "(prefers-reduced-motion: reduce)";
var CREATED = 1;
var MOUNTED = 2;
var IDLE = 3;
var MOVING = 4;
var SCROLLING = 5;
var DRAGGING = 6;
var DESTROYED = 7;
var STATES = {
  CREATED,
  MOUNTED,
  IDLE,
  MOVING,
  SCROLLING,
  DRAGGING,
  DESTROYED
};
function empty2(array) {
  array.length = 0;
}
function slice(arrayLike, start, end) {
  return Array.prototype.slice.call(arrayLike, start, end);
}
function apply(func) {
  return func.bind.apply(func, [null].concat(slice(arguments, 1)));
}
var nextTick = setTimeout;
var noop2 = function noop3() {
};
function raf(func) {
  return requestAnimationFrame(func);
}
function typeOf(type, subject) {
  return typeof subject === type;
}
function isObject2(subject) {
  return !isNull(subject) && typeOf("object", subject);
}
var isArray = Array.isArray;
var isFunction = apply(typeOf, "function");
var isString = apply(typeOf, "string");
var isUndefined = apply(typeOf, "undefined");
function isNull(subject) {
  return subject === null;
}
function isHTMLElement(subject) {
  try {
    return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;
  } catch (e) {
    return false;
  }
}
function toArray(value) {
  return isArray(value) ? value : [value];
}
function forEach(values, iteratee) {
  toArray(values).forEach(iteratee);
}
function includes(array, value) {
  return array.indexOf(value) > -1;
}
function push(array, items) {
  array.push.apply(array, toArray(items));
  return array;
}
function toggleClass(elm, classes, add) {
  if (elm) {
    forEach(classes, function(name) {
      if (name) {
        elm.classList[add ? "add" : "remove"](name);
      }
    });
  }
}
function addClass(elm, classes) {
  toggleClass(elm, isString(classes) ? classes.split(" ") : classes, true);
}
function append(parent, children2) {
  forEach(children2, parent.appendChild.bind(parent));
}
function before(nodes, ref) {
  forEach(nodes, function(node) {
    var parent = (ref || node).parentNode;
    if (parent) {
      parent.insertBefore(node, ref);
    }
  });
}
function matches(elm, selector) {
  return isHTMLElement(elm) && (elm["msMatchesSelector"] || elm.matches).call(elm, selector);
}
function children(parent, selector) {
  var children2 = parent ? slice(parent.children) : [];
  return selector ? children2.filter(function(child2) {
    return matches(child2, selector);
  }) : children2;
}
function child(parent, selector) {
  return selector ? children(parent, selector)[0] : parent.firstElementChild;
}
var ownKeys = Object.keys;
function forOwn2(object, iteratee, right) {
  if (object) {
    (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function(key) {
      key !== "__proto__" && iteratee(object[key], key);
    });
  }
  return object;
}
function assign2(object) {
  slice(arguments, 1).forEach(function(source) {
    forOwn2(source, function(value, key) {
      object[key] = source[key];
    });
  });
  return object;
}
function merge2(object) {
  slice(arguments, 1).forEach(function(source) {
    forOwn2(source, function(value, key) {
      if (isArray(value)) {
        object[key] = value.slice();
      } else if (isObject2(value)) {
        object[key] = merge2({}, isObject2(object[key]) ? object[key] : {}, value);
      } else {
        object[key] = value;
      }
    });
  });
  return object;
}
function omit(object, keys) {
  forEach(keys || ownKeys(object), function(key) {
    delete object[key];
  });
}
function removeAttribute(elms, attrs) {
  forEach(elms, function(elm) {
    forEach(attrs, function(attr) {
      elm && elm.removeAttribute(attr);
    });
  });
}
function setAttribute(elms, attrs, value) {
  if (isObject2(attrs)) {
    forOwn2(attrs, function(value2, name) {
      setAttribute(elms, name, value2);
    });
  } else {
    forEach(elms, function(elm) {
      isNull(value) || value === "" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));
    });
  }
}
function create(tag, attrs, parent) {
  var elm = document.createElement(tag);
  if (attrs) {
    isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);
  }
  parent && append(parent, elm);
  return elm;
}
function style(elm, prop, value) {
  if (isUndefined(value)) {
    return getComputedStyle(elm)[prop];
  }
  if (!isNull(value)) {
    elm.style[prop] = "" + value;
  }
}
function display(elm, display2) {
  style(elm, "display", display2);
}
function focus(elm) {
  elm["setActive"] && elm["setActive"]() || elm.focus({
    preventScroll: true
  });
}
function getAttribute(elm, attr) {
  return elm.getAttribute(attr);
}
function hasClass(elm, className) {
  return elm && elm.classList.contains(className);
}
function rect(target) {
  return target.getBoundingClientRect();
}
function remove(nodes) {
  forEach(nodes, function(node) {
    if (node && node.parentNode) {
      node.parentNode.removeChild(node);
    }
  });
}
function parseHtml(html) {
  return child(new DOMParser().parseFromString(html, "text/html").body);
}
function prevent(e, stopPropagation) {
  e.preventDefault();
  if (stopPropagation) {
    e.stopPropagation();
    e.stopImmediatePropagation();
  }
}
function query(parent, selector) {
  return parent && parent.querySelector(selector);
}
function queryAll(parent, selector) {
  return selector ? slice(parent.querySelectorAll(selector)) : [];
}
function removeClass(elm, classes) {
  toggleClass(elm, classes, false);
}
function timeOf(e) {
  return e.timeStamp;
}
function unit(value) {
  return isString(value) ? value : value ? value + "px" : "";
}
var PROJECT_CODE = "splide";
var DATA_ATTRIBUTE = "data-" + PROJECT_CODE;
function assert(condition, message) {
  if (!condition) {
    throw new Error("[" + PROJECT_CODE + "] " + (message || ""));
  }
}
var min = Math.min;
var max = Math.max;
var floor = Math.floor;
var ceil = Math.ceil;
var abs = Math.abs;
function approximatelyEqual(x, y, epsilon) {
  return abs(x - y) < epsilon;
}
function between(number, x, y, exclusive) {
  var minimum = min(x, y);
  var maximum = max(x, y);
  return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;
}
function clamp(number, x, y) {
  var minimum = min(x, y);
  var maximum = max(x, y);
  return min(max(minimum, number), maximum);
}
function sign(x) {
  return +(x > 0) - +(x < 0);
}
function camelToKebab(string) {
  return string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function format(string, replacements) {
  forEach(replacements, function(replacement) {
    string = string.replace("%s", "" + replacement);
  });
  return string;
}
function pad(number) {
  return number < 10 ? "0" + number : "" + number;
}
var ids = {};
function uniqueId(prefix) {
  return "" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);
}
function EventBinder() {
  var listeners = [];
  function bind2(targets, events, callback, options) {
    forEachEvent(targets, events, function(target, event, namespace) {
      var isEventTarget = "addEventListener" in target;
      var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target["removeListener"].bind(target, callback);
      isEventTarget ? target.addEventListener(event, callback, options) : target["addListener"](callback);
      listeners.push([target, event, namespace, callback, remover]);
    });
  }
  function unbind(targets, events, callback) {
    forEachEvent(targets, events, function(target, event, namespace) {
      listeners = listeners.filter(function(listener) {
        if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {
          listener[4]();
          return false;
        }
        return true;
      });
    });
  }
  function dispatch(target, type, detail) {
    var e;
    var bubbles = true;
    if (typeof CustomEvent === "function") {
      e = new CustomEvent(type, {
        bubbles,
        detail
      });
    } else {
      e = document.createEvent("CustomEvent");
      e.initCustomEvent(type, bubbles, false, detail);
    }
    target.dispatchEvent(e);
    return e;
  }
  function forEachEvent(targets, events, iteratee) {
    forEach(targets, function(target) {
      target && forEach(events, function(events2) {
        events2.split(" ").forEach(function(eventNS) {
          var fragment = eventNS.split(".");
          iteratee(target, fragment[0], fragment[1]);
        });
      });
    });
  }
  function destroy() {
    listeners.forEach(function(data) {
      data[4]();
    });
    empty2(listeners);
  }
  return {
    bind: bind2,
    unbind,
    dispatch,
    destroy
  };
}
var EVENT_MOUNTED = "mounted";
var EVENT_READY = "ready";
var EVENT_MOVE = "move";
var EVENT_MOVED = "moved";
var EVENT_CLICK = "click";
var EVENT_ACTIVE = "active";
var EVENT_INACTIVE = "inactive";
var EVENT_VISIBLE = "visible";
var EVENT_HIDDEN = "hidden";
var EVENT_REFRESH = "refresh";
var EVENT_UPDATED = "updated";
var EVENT_RESIZE = "resize";
var EVENT_RESIZED = "resized";
var EVENT_DRAG = "drag";
var EVENT_DRAGGING = "dragging";
var EVENT_DRAGGED = "dragged";
var EVENT_SCROLL = "scroll";
var EVENT_SCROLLED = "scrolled";
var EVENT_OVERFLOW = "overflow";
var EVENT_DESTROY = "destroy";
var EVENT_ARROWS_MOUNTED = "arrows:mounted";
var EVENT_ARROWS_UPDATED = "arrows:updated";
var EVENT_PAGINATION_MOUNTED = "pagination:mounted";
var EVENT_PAGINATION_UPDATED = "pagination:updated";
var EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
var EVENT_AUTOPLAY_PLAY = "autoplay:play";
var EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
var EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
var EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
var EVENT_SLIDE_KEYDOWN = "sk";
var EVENT_SHIFTED = "sh";
var EVENT_END_INDEX_CHANGED = "ei";
function EventInterface(Splide2) {
  var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();
  var binder = EventBinder();
  function on(events, callback) {
    binder.bind(bus, toArray(events).join(" "), function(e) {
      callback.apply(callback, isArray(e.detail) ? e.detail : []);
    });
  }
  function emit(event) {
    binder.dispatch(bus, event, slice(arguments, 1));
  }
  if (Splide2) {
    Splide2.event.on(EVENT_DESTROY, binder.destroy);
  }
  return assign2(binder, {
    bus,
    on,
    off: apply(binder.unbind, bus),
    emit
  });
}
function RequestInterval(interval, onInterval, onUpdate, limit) {
  var now = Date.now;
  var startTime;
  var rate = 0;
  var id;
  var paused = true;
  var count = 0;
  function update() {
    if (!paused) {
      rate = interval ? min((now() - startTime) / interval, 1) : 1;
      onUpdate && onUpdate(rate);
      if (rate >= 1) {
        onInterval();
        startTime = now();
        if (limit && ++count >= limit) {
          return pause();
        }
      }
      id = raf(update);
    }
  }
  function start(resume) {
    resume || cancel();
    startTime = now() - (resume ? rate * interval : 0);
    paused = false;
    id = raf(update);
  }
  function pause() {
    paused = true;
  }
  function rewind() {
    startTime = now();
    rate = 0;
    if (onUpdate) {
      onUpdate(rate);
    }
  }
  function cancel() {
    id && cancelAnimationFrame(id);
    rate = 0;
    id = 0;
    paused = true;
  }
  function set(time) {
    interval = time;
  }
  function isPaused() {
    return paused;
  }
  return {
    start,
    rewind,
    pause,
    cancel,
    set,
    isPaused
  };
}
function State(initialState) {
  var state = initialState;
  function set(value) {
    state = value;
  }
  function is(states) {
    return includes(toArray(states), state);
  }
  return {
    set,
    is
  };
}
function Throttle(func, duration) {
  var interval = RequestInterval(duration || 0, func, null, 1);
  return function() {
    interval.isPaused() && interval.start();
  };
}
function Media(Splide2, Components2, options) {
  var state = Splide2.state;
  var breakpoints = options.breakpoints || {};
  var reducedMotion = options.reducedMotion || {};
  var binder = EventBinder();
  var queries = [];
  function setup() {
    var isMin = options.mediaQuery === "min";
    ownKeys(breakpoints).sort(function(n, m) {
      return isMin ? +n - +m : +m - +n;
    }).forEach(function(key) {
      register(breakpoints[key], "(" + (isMin ? "min" : "max") + "-width:" + key + "px)");
    });
    register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);
    update();
  }
  function destroy(completely) {
    if (completely) {
      binder.destroy();
    }
  }
  function register(options2, query2) {
    var queryList = matchMedia(query2);
    binder.bind(queryList, "change", update);
    queries.push([options2, queryList]);
  }
  function update() {
    var destroyed = state.is(DESTROYED);
    var direction = options.direction;
    var merged = queries.reduce(function(merged2, entry) {
      return merge2(merged2, entry[1].matches ? entry[0] : {});
    }, {});
    omit(options);
    set(merged);
    if (options.destroy) {
      Splide2.destroy(options.destroy === "completely");
    } else if (destroyed) {
      destroy(true);
      Splide2.mount();
    } else {
      direction !== options.direction && Splide2.refresh();
    }
  }
  function reduce(enable) {
    if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {
      enable ? merge2(options, reducedMotion) : omit(options, ownKeys(reducedMotion));
    }
  }
  function set(opts, base, notify) {
    merge2(options, opts);
    base && merge2(Object.getPrototypeOf(options), opts);
    if (notify || !state.is(CREATED)) {
      Splide2.emit(EVENT_UPDATED, options);
    }
  }
  return {
    setup,
    destroy,
    reduce,
    set
  };
}
var ARROW = "Arrow";
var ARROW_LEFT = ARROW + "Left";
var ARROW_RIGHT = ARROW + "Right";
var ARROW_UP = ARROW + "Up";
var ARROW_DOWN = ARROW + "Down";
var RTL = "rtl";
var TTB = "ttb";
var ORIENTATION_MAP = {
  width: ["height"],
  left: ["top", "right"],
  right: ["bottom", "left"],
  x: ["y"],
  X: ["Y"],
  Y: ["X"],
  ArrowLeft: [ARROW_UP, ARROW_RIGHT],
  ArrowRight: [ARROW_DOWN, ARROW_LEFT]
};
function Direction(Splide2, Components2, options) {
  function resolve(prop, axisOnly, direction) {
    direction = direction || options.direction;
    var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
    return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function(match, offset) {
      var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;
      return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;
    });
  }
  function orient(value) {
    return value * (options.direction === RTL ? 1 : -1);
  }
  return {
    resolve,
    orient
  };
}
var ROLE = "role";
var TAB_INDEX = "tabindex";
var DISABLED = "disabled";
var ARIA_PREFIX = "aria-";
var ARIA_CONTROLS = ARIA_PREFIX + "controls";
var ARIA_CURRENT = ARIA_PREFIX + "current";
var ARIA_SELECTED = ARIA_PREFIX + "selected";
var ARIA_LABEL = ARIA_PREFIX + "label";
var ARIA_LABELLEDBY = ARIA_PREFIX + "labelledby";
var ARIA_HIDDEN = ARIA_PREFIX + "hidden";
var ARIA_ORIENTATION = ARIA_PREFIX + "orientation";
var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + "roledescription";
var ARIA_LIVE = ARIA_PREFIX + "live";
var ARIA_BUSY = ARIA_PREFIX + "busy";
var ARIA_ATOMIC = ARIA_PREFIX + "atomic";
var ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];
var CLASS_PREFIX = PROJECT_CODE + "__";
var STATUS_CLASS_PREFIX = "is-";
var CLASS_ROOT = PROJECT_CODE;
var CLASS_TRACK = CLASS_PREFIX + "track";
var CLASS_LIST = CLASS_PREFIX + "list";
var CLASS_SLIDE = CLASS_PREFIX + "slide";
var CLASS_CLONE = CLASS_SLIDE + "--clone";
var CLASS_CONTAINER = CLASS_SLIDE + "__container";
var CLASS_ARROWS = CLASS_PREFIX + "arrows";
var CLASS_ARROW = CLASS_PREFIX + "arrow";
var CLASS_ARROW_PREV = CLASS_ARROW + "--prev";
var CLASS_ARROW_NEXT = CLASS_ARROW + "--next";
var CLASS_PAGINATION = CLASS_PREFIX + "pagination";
var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + "__page";
var CLASS_PROGRESS = CLASS_PREFIX + "progress";
var CLASS_PROGRESS_BAR = CLASS_PROGRESS + "__bar";
var CLASS_TOGGLE = CLASS_PREFIX + "toggle";
var CLASS_TOGGLE_PLAY = CLASS_TOGGLE + "__play";
var CLASS_TOGGLE_PAUSE = CLASS_TOGGLE + "__pause";
var CLASS_SPINNER = CLASS_PREFIX + "spinner";
var CLASS_SR = CLASS_PREFIX + "sr";
var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + "initialized";
var CLASS_ACTIVE = STATUS_CLASS_PREFIX + "active";
var CLASS_PREV = STATUS_CLASS_PREFIX + "prev";
var CLASS_NEXT = STATUS_CLASS_PREFIX + "next";
var CLASS_VISIBLE = STATUS_CLASS_PREFIX + "visible";
var CLASS_LOADING = STATUS_CLASS_PREFIX + "loading";
var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + "focus-in";
var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + "overflow";
var STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW];
var CLASSES = {
  slide: CLASS_SLIDE,
  clone: CLASS_CLONE,
  arrows: CLASS_ARROWS,
  arrow: CLASS_ARROW,
  prev: CLASS_ARROW_PREV,
  next: CLASS_ARROW_NEXT,
  pagination: CLASS_PAGINATION,
  page: CLASS_PAGINATION_PAGE,
  spinner: CLASS_SPINNER
};
function closest(from, selector) {
  if (isFunction(from.closest)) {
    return from.closest(selector);
  }
  var elm = from;
  while (elm && elm.nodeType === 1) {
    if (matches(elm, selector)) {
      break;
    }
    elm = elm.parentElement;
  }
  return elm;
}
var FRICTION = 5;
var LOG_INTERVAL = 200;
var POINTER_DOWN_EVENTS = "touchstart mousedown";
var POINTER_MOVE_EVENTS = "touchmove mousemove";
var POINTER_UP_EVENTS = "touchend touchcancel mouseup click";
function Elements(Splide2, Components2, options) {
  var _EventInterface = EventInterface(Splide2), on = _EventInterface.on, bind2 = _EventInterface.bind;
  var root = Splide2.root;
  var i18n = options.i18n;
  var elements = {};
  var slides = [];
  var rootClasses = [];
  var trackClasses = [];
  var track;
  var list;
  var isUsingKey;
  function setup() {
    collect();
    init2();
    update();
  }
  function mount() {
    on(EVENT_REFRESH, destroy);
    on(EVENT_REFRESH, setup);
    on(EVENT_UPDATED, update);
    bind2(document, POINTER_DOWN_EVENTS + " keydown", function(e) {
      isUsingKey = e.type === "keydown";
    }, {
      capture: true
    });
    bind2(root, "focusin", function() {
      toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);
    });
  }
  function destroy(completely) {
    var attrs = ALL_ATTRIBUTES.concat("style");
    empty2(slides);
    removeClass(root, rootClasses);
    removeClass(track, trackClasses);
    removeAttribute([track, list], attrs);
    removeAttribute(root, completely ? attrs : ["style", ARIA_ROLEDESCRIPTION]);
  }
  function update() {
    removeClass(root, rootClasses);
    removeClass(track, trackClasses);
    rootClasses = getClasses(CLASS_ROOT);
    trackClasses = getClasses(CLASS_TRACK);
    addClass(root, rootClasses);
    addClass(track, trackClasses);
    setAttribute(root, ARIA_LABEL, options.label);
    setAttribute(root, ARIA_LABELLEDBY, options.labelledby);
  }
  function collect() {
    track = find("." + CLASS_TRACK);
    list = child(track, "." + CLASS_LIST);
    assert(track && list, "A track/list element is missing.");
    push(slides, children(list, "." + CLASS_SLIDE + ":not(." + CLASS_CLONE + ")"));
    forOwn2({
      arrows: CLASS_ARROWS,
      pagination: CLASS_PAGINATION,
      prev: CLASS_ARROW_PREV,
      next: CLASS_ARROW_NEXT,
      bar: CLASS_PROGRESS_BAR,
      toggle: CLASS_TOGGLE
    }, function(className, key) {
      elements[key] = find("." + className);
    });
    assign2(elements, {
      root,
      track,
      list,
      slides
    });
  }
  function init2() {
    var id = root.id || uniqueId(PROJECT_CODE);
    var role = options.role;
    root.id = id;
    track.id = track.id || id + "-track";
    list.id = list.id || id + "-list";
    if (!getAttribute(root, ROLE) && root.tagName !== "SECTION" && role) {
      setAttribute(root, ROLE, role);
    }
    setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);
    setAttribute(list, ROLE, "presentation");
  }
  function find(selector) {
    var elm = query(root, selector);
    return elm && closest(elm, "." + CLASS_ROOT) === root ? elm : void 0;
  }
  function getClasses(base) {
    return [base + "--" + options.type, base + "--" + options.direction, options.drag && base + "--draggable", options.isNavigation && base + "--nav", base === CLASS_ROOT && CLASS_ACTIVE];
  }
  return assign2(elements, {
    setup,
    mount,
    destroy
  });
}
var SLIDE = "slide";
var LOOP = "loop";
var FADE = "fade";
function Slide$1(Splide2, index, slideIndex, slide) {
  var event = EventInterface(Splide2);
  var on = event.on, emit = event.emit, bind2 = event.bind;
  var Components = Splide2.Components, root = Splide2.root, options = Splide2.options;
  var isNavigation = options.isNavigation, updateOnMove = options.updateOnMove, i18n = options.i18n, pagination = options.pagination, slideFocus = options.slideFocus;
  var resolve = Components.Direction.resolve;
  var styles = getAttribute(slide, "style");
  var label = getAttribute(slide, ARIA_LABEL);
  var isClone = slideIndex > -1;
  var container = child(slide, "." + CLASS_CONTAINER);
  var destroyed;
  function mount() {
    if (!isClone) {
      slide.id = root.id + "-slide" + pad(index + 1);
      setAttribute(slide, ROLE, pagination ? "tabpanel" : "group");
      setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);
      setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]));
    }
    listen();
  }
  function listen() {
    bind2(slide, "click", apply(emit, EVENT_CLICK, self));
    bind2(slide, "keydown", apply(emit, EVENT_SLIDE_KEYDOWN, self));
    on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);
    on(EVENT_NAVIGATION_MOUNTED, initNavigation);
    if (updateOnMove) {
      on(EVENT_MOVE, onMove);
    }
  }
  function destroy() {
    destroyed = true;
    event.destroy();
    removeClass(slide, STATUS_CLASSES);
    removeAttribute(slide, ALL_ATTRIBUTES);
    setAttribute(slide, "style", styles);
    setAttribute(slide, ARIA_LABEL, label || "");
  }
  function initNavigation() {
    var controls = Splide2.splides.map(function(target) {
      var Slide2 = target.splide.Components.Slides.getAt(index);
      return Slide2 ? Slide2.slide.id : "";
    }).join(" ");
    setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));
    setAttribute(slide, ARIA_CONTROLS, controls);
    setAttribute(slide, ROLE, slideFocus ? "button" : "");
    slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);
  }
  function onMove() {
    if (!destroyed) {
      update();
    }
  }
  function update() {
    if (!destroyed) {
      var curr = Splide2.index;
      updateActivity();
      updateVisibility();
      toggleClass(slide, CLASS_PREV, index === curr - 1);
      toggleClass(slide, CLASS_NEXT, index === curr + 1);
    }
  }
  function updateActivity() {
    var active = isActive();
    if (active !== hasClass(slide, CLASS_ACTIVE)) {
      toggleClass(slide, CLASS_ACTIVE, active);
      setAttribute(slide, ARIA_CURRENT, isNavigation && active || "");
      emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);
    }
  }
  function updateVisibility() {
    var visible = isVisible();
    var hidden = !visible && (!isActive() || isClone);
    if (!Splide2.state.is([MOVING, SCROLLING])) {
      setAttribute(slide, ARIA_HIDDEN, hidden || "");
    }
    setAttribute(queryAll(slide, options.focusableNodes || ""), TAB_INDEX, hidden ? -1 : "");
    if (slideFocus) {
      setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);
    }
    if (visible !== hasClass(slide, CLASS_VISIBLE)) {
      toggleClass(slide, CLASS_VISIBLE, visible);
      emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);
    }
    if (!visible && document.activeElement === slide) {
      var Slide2 = Components.Slides.getAt(Splide2.index);
      Slide2 && focus(Slide2.slide);
    }
  }
  function style$1(prop, value, useContainer) {
    style(useContainer && container || slide, prop, value);
  }
  function isActive() {
    var curr = Splide2.index;
    return curr === index || options.cloneStatus && curr === slideIndex;
  }
  function isVisible() {
    if (Splide2.is(FADE)) {
      return isActive();
    }
    var trackRect = rect(Components.Elements.track);
    var slideRect = rect(slide);
    var left = resolve("left", true);
    var right = resolve("right", true);
    return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);
  }
  function isWithin(from, distance) {
    var diff = abs(from - index);
    if (!isClone && (options.rewind || Splide2.is(LOOP))) {
      diff = min(diff, Splide2.length - diff);
    }
    return diff <= distance;
  }
  var self = {
    index,
    slideIndex,
    slide,
    container,
    isClone,
    mount,
    destroy,
    update,
    style: style$1,
    isWithin
  };
  return self;
}
function Slides(Splide2, Components2, options) {
  var _EventInterface2 = EventInterface(Splide2), on = _EventInterface2.on, emit = _EventInterface2.emit, bind2 = _EventInterface2.bind;
  var _Components2$Elements = Components2.Elements, slides = _Components2$Elements.slides, list = _Components2$Elements.list;
  var Slides2 = [];
  function mount() {
    init2();
    on(EVENT_REFRESH, destroy);
    on(EVENT_REFRESH, init2);
  }
  function init2() {
    slides.forEach(function(slide, index) {
      register(slide, index, -1);
    });
  }
  function destroy() {
    forEach$1(function(Slide2) {
      Slide2.destroy();
    });
    empty2(Slides2);
  }
  function update() {
    forEach$1(function(Slide2) {
      Slide2.update();
    });
  }
  function register(slide, index, slideIndex) {
    var object = Slide$1(Splide2, index, slideIndex, slide);
    object.mount();
    Slides2.push(object);
    Slides2.sort(function(Slide1, Slide2) {
      return Slide1.index - Slide2.index;
    });
  }
  function get(excludeClones) {
    return excludeClones ? filter(function(Slide2) {
      return !Slide2.isClone;
    }) : Slides2;
  }
  function getIn(page) {
    var Controller2 = Components2.Controller;
    var index = Controller2.toIndex(page);
    var max2 = Controller2.hasFocus() ? 1 : options.perPage;
    return filter(function(Slide2) {
      return between(Slide2.index, index, index + max2 - 1);
    });
  }
  function getAt(index) {
    return filter(index)[0];
  }
  function add(items, index) {
    forEach(items, function(slide) {
      if (isString(slide)) {
        slide = parseHtml(slide);
      }
      if (isHTMLElement(slide)) {
        var ref = slides[index];
        ref ? before(slide, ref) : append(list, slide);
        addClass(slide, options.classes.slide);
        observeImages(slide, apply(emit, EVENT_RESIZE));
      }
    });
    emit(EVENT_REFRESH);
  }
  function remove$1(matcher) {
    remove(filter(matcher).map(function(Slide2) {
      return Slide2.slide;
    }));
    emit(EVENT_REFRESH);
  }
  function forEach$1(iteratee, excludeClones) {
    get(excludeClones).forEach(iteratee);
  }
  function filter(matcher) {
    return Slides2.filter(isFunction(matcher) ? matcher : function(Slide2) {
      return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);
    });
  }
  function style2(prop, value, useContainer) {
    forEach$1(function(Slide2) {
      Slide2.style(prop, value, useContainer);
    });
  }
  function observeImages(elm, callback) {
    var images = queryAll(elm, "img");
    var length = images.length;
    if (length) {
      images.forEach(function(img) {
        bind2(img, "load error", function() {
          if (!--length) {
            callback();
          }
        });
      });
    } else {
      callback();
    }
  }
  function getLength(excludeClones) {
    return excludeClones ? slides.length : Slides2.length;
  }
  function isEnough() {
    return Slides2.length > options.perPage;
  }
  return {
    mount,
    destroy,
    update,
    register,
    get,
    getIn,
    getAt,
    add,
    remove: remove$1,
    forEach: forEach$1,
    filter,
    style: style2,
    getLength,
    isEnough
  };
}
function Layout(Splide2, Components2, options) {
  var _EventInterface3 = EventInterface(Splide2), on = _EventInterface3.on, bind2 = _EventInterface3.bind, emit = _EventInterface3.emit;
  var Slides2 = Components2.Slides;
  var resolve = Components2.Direction.resolve;
  var _Components2$Elements2 = Components2.Elements, root = _Components2$Elements2.root, track = _Components2$Elements2.track, list = _Components2$Elements2.list;
  var getAt = Slides2.getAt, styleSlides = Slides2.style;
  var vertical;
  var rootRect;
  var overflow;
  function mount() {
    init2();
    bind2(window, "resize load", Throttle(apply(emit, EVENT_RESIZE)));
    on([EVENT_UPDATED, EVENT_REFRESH], init2);
    on(EVENT_RESIZE, resize);
  }
  function init2() {
    vertical = options.direction === TTB;
    style(root, "maxWidth", unit(options.width));
    style(track, resolve("paddingLeft"), cssPadding(false));
    style(track, resolve("paddingRight"), cssPadding(true));
    resize(true);
  }
  function resize(force) {
    var newRect = rect(root);
    if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
      style(track, "height", cssTrackHeight());
      styleSlides(resolve("marginRight"), unit(options.gap));
      styleSlides("width", cssSlideWidth());
      styleSlides("height", cssSlideHeight(), true);
      rootRect = newRect;
      emit(EVENT_RESIZED);
      if (overflow !== (overflow = isOverflow())) {
        toggleClass(root, CLASS_OVERFLOW, overflow);
        emit(EVENT_OVERFLOW, overflow);
      }
    }
  }
  function cssPadding(right) {
    var padding = options.padding;
    var prop = resolve(right ? "right" : "left");
    return padding && unit(padding[prop] || (isObject2(padding) ? 0 : padding)) || "0px";
  }
  function cssTrackHeight() {
    var height = "";
    if (vertical) {
      height = cssHeight();
      assert(height, "height or heightRatio is missing.");
      height = "calc(" + height + " - " + cssPadding(false) + " - " + cssPadding(true) + ")";
    }
    return height;
  }
  function cssHeight() {
    return unit(options.height || rect(list).width * options.heightRatio);
  }
  function cssSlideWidth() {
    return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize());
  }
  function cssSlideHeight() {
    return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());
  }
  function cssSlideSize() {
    var gap = unit(options.gap);
    return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
  }
  function listSize() {
    return rect(list)[resolve("width")];
  }
  function slideSize(index, withoutGap) {
    var Slide2 = getAt(index || 0);
    return Slide2 ? rect(Slide2.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0;
  }
  function totalSize(index, withoutGap) {
    var Slide2 = getAt(index);
    if (Slide2) {
      var right = rect(Slide2.slide)[resolve("right")];
      var left = rect(list)[resolve("left")];
      return abs(right - left) + (withoutGap ? 0 : getGap());
    }
    return 0;
  }
  function sliderSize(withoutGap) {
    return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap);
  }
  function getGap() {
    var Slide2 = getAt(0);
    return Slide2 && parseFloat(style(Slide2.slide, resolve("marginRight"))) || 0;
  }
  function getPadding(right) {
    return parseFloat(style(track, resolve("padding" + (right ? "Right" : "Left")))) || 0;
  }
  function isOverflow() {
    return Splide2.is(FADE) || sliderSize(true) > listSize();
  }
  return {
    mount,
    resize,
    listSize,
    slideSize,
    sliderSize,
    totalSize,
    getPadding,
    isOverflow
  };
}
var MULTIPLIER = 2;
function Clones(Splide2, Components2, options) {
  var event = EventInterface(Splide2);
  var on = event.on;
  var Elements2 = Components2.Elements, Slides2 = Components2.Slides;
  var resolve = Components2.Direction.resolve;
  var clones = [];
  var cloneCount;
  function mount() {
    on(EVENT_REFRESH, remount);
    on([EVENT_UPDATED, EVENT_RESIZE], observe);
    if (cloneCount = computeCloneCount()) {
      generate(cloneCount);
      Components2.Layout.resize(true);
    }
  }
  function remount() {
    destroy();
    mount();
  }
  function destroy() {
    remove(clones);
    empty2(clones);
    event.destroy();
  }
  function observe() {
    var count = computeCloneCount();
    if (cloneCount !== count) {
      if (cloneCount < count || !count) {
        event.emit(EVENT_REFRESH);
      }
    }
  }
  function generate(count) {
    var slides = Slides2.get().slice();
    var length = slides.length;
    if (length) {
      while (slides.length < count) {
        push(slides, slides);
      }
      push(slides.slice(-count), slides.slice(0, count)).forEach(function(Slide2, index) {
        var isHead = index < count;
        var clone = cloneDeep(Slide2.slide, index);
        isHead ? before(clone, slides[0].slide) : append(Elements2.list, clone);
        push(clones, clone);
        Slides2.register(clone, index - count + (isHead ? 0 : length), Slide2.index);
      });
    }
  }
  function cloneDeep(elm, index) {
    var clone = elm.cloneNode(true);
    addClass(clone, options.classes.clone);
    clone.id = Splide2.root.id + "-clone" + pad(index + 1);
    return clone;
  }
  function computeCloneCount() {
    var clones2 = options.clones;
    if (!Splide2.is(LOOP)) {
      clones2 = 0;
    } else if (isUndefined(clones2)) {
      var fixedSize = options[resolve("fixedWidth")] && Components2.Layout.slideSize(0);
      var fixedCount = fixedSize && ceil(rect(Elements2.track)[resolve("width")] / fixedSize);
      clones2 = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage * MULTIPLIER;
    }
    return clones2;
  }
  return {
    mount,
    destroy
  };
}
function Move(Splide2, Components2, options) {
  var _EventInterface4 = EventInterface(Splide2), on = _EventInterface4.on, emit = _EventInterface4.emit;
  var set = Splide2.state.set;
  var _Components2$Layout = Components2.Layout, slideSize = _Components2$Layout.slideSize, getPadding = _Components2$Layout.getPadding, totalSize = _Components2$Layout.totalSize, listSize = _Components2$Layout.listSize, sliderSize = _Components2$Layout.sliderSize;
  var _Components2$Directio = Components2.Direction, resolve = _Components2$Directio.resolve, orient = _Components2$Directio.orient;
  var _Components2$Elements3 = Components2.Elements, list = _Components2$Elements3.list, track = _Components2$Elements3.track;
  var Transition;
  function mount() {
    Transition = Components2.Transition;
    on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);
  }
  function reposition() {
    if (!Components2.Controller.isBusy()) {
      Components2.Scroll.cancel();
      jump(Splide2.index);
      Components2.Slides.update();
    }
  }
  function move(dest, index, prev, callback) {
    if (dest !== index && canShift(dest > prev)) {
      cancel();
      translate(shift(getPosition(), dest > prev), true);
    }
    set(MOVING);
    emit(EVENT_MOVE, index, prev, dest);
    Transition.start(index, function() {
      set(IDLE);
      emit(EVENT_MOVED, index, prev, dest);
      callback && callback();
    });
  }
  function jump(index) {
    translate(toPosition(index, true));
  }
  function translate(position, preventLoop) {
    if (!Splide2.is(FADE)) {
      var destination = preventLoop ? position : loop(position);
      style(list, "transform", "translate" + resolve("X") + "(" + destination + "px)");
      position !== destination && emit(EVENT_SHIFTED);
    }
  }
  function loop(position) {
    if (Splide2.is(LOOP)) {
      var index = toIndex(position);
      var exceededMax = index > Components2.Controller.getEnd();
      var exceededMin = index < 0;
      if (exceededMin || exceededMax) {
        position = shift(position, exceededMax);
      }
    }
    return position;
  }
  function shift(position, backwards) {
    var excess = position - getLimit(backwards);
    var size = sliderSize();
    position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
    return position;
  }
  function cancel() {
    translate(getPosition(), true);
    Transition.cancel();
  }
  function toIndex(position) {
    var Slides2 = Components2.Slides.get();
    var index = 0;
    var minDistance = Infinity;
    for (var i = 0; i < Slides2.length; i++) {
      var slideIndex = Slides2[i].index;
      var distance = abs(toPosition(slideIndex, true) - position);
      if (distance <= minDistance) {
        minDistance = distance;
        index = slideIndex;
      } else {
        break;
      }
    }
    return index;
  }
  function toPosition(index, trimming) {
    var position = orient(totalSize(index - 1) - offset(index));
    return trimming ? trim(position) : position;
  }
  function getPosition() {
    var left = resolve("left");
    return rect(list)[left] - rect(track)[left] + orient(getPadding(false));
  }
  function trim(position) {
    if (options.trimSpace && Splide2.is(SLIDE)) {
      position = clamp(position, 0, orient(sliderSize(true) - listSize()));
    }
    return position;
  }
  function offset(index) {
    var focus2 = options.focus;
    return focus2 === "center" ? (listSize() - slideSize(index, true)) / 2 : +focus2 * slideSize(index) || 0;
  }
  function getLimit(max2) {
    return toPosition(max2 ? Components2.Controller.getEnd() : 0, !!options.trimSpace);
  }
  function canShift(backwards) {
    var shifted = orient(shift(getPosition(), backwards));
    return backwards ? shifted >= 0 : shifted <= list[resolve("scrollWidth")] - rect(track)[resolve("width")];
  }
  function exceededLimit(max2, position) {
    position = isUndefined(position) ? getPosition() : position;
    var exceededMin = max2 !== true && orient(position) < orient(getLimit(false));
    var exceededMax = max2 !== false && orient(position) > orient(getLimit(true));
    return exceededMin || exceededMax;
  }
  return {
    mount,
    move,
    jump,
    translate,
    shift,
    cancel,
    toIndex,
    toPosition,
    getPosition,
    getLimit,
    exceededLimit,
    reposition
  };
}
function Controller(Splide2, Components2, options) {
  var _EventInterface5 = EventInterface(Splide2), on = _EventInterface5.on, emit = _EventInterface5.emit;
  var Move2 = Components2.Move;
  var getPosition = Move2.getPosition, getLimit = Move2.getLimit, toPosition = Move2.toPosition;
  var _Components2$Slides = Components2.Slides, isEnough = _Components2$Slides.isEnough, getLength = _Components2$Slides.getLength;
  var omitEnd = options.omitEnd;
  var isLoop = Splide2.is(LOOP);
  var isSlide = Splide2.is(SLIDE);
  var getNext = apply(getAdjacent, false);
  var getPrev = apply(getAdjacent, true);
  var currIndex = options.start || 0;
  var endIndex;
  var prevIndex = currIndex;
  var slideCount;
  var perMove;
  var perPage;
  function mount() {
    init2();
    on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], init2);
    on(EVENT_RESIZED, onResized);
  }
  function init2() {
    slideCount = getLength(true);
    perMove = options.perMove;
    perPage = options.perPage;
    endIndex = getEnd();
    var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);
    if (index !== currIndex) {
      currIndex = index;
      Move2.reposition();
    }
  }
  function onResized() {
    if (endIndex !== getEnd()) {
      emit(EVENT_END_INDEX_CHANGED);
    }
  }
  function go(control, allowSameIndex, callback) {
    if (!isBusy()) {
      var dest = parse(control);
      var index = loop(dest);
      if (index > -1 && (allowSameIndex || index !== currIndex)) {
        setIndex(index);
        Move2.move(dest, index, prevIndex, callback);
      }
    }
  }
  function scroll(destination, duration, snap, callback) {
    Components2.Scroll.scroll(destination, duration, snap, function() {
      var index = loop(Move2.toIndex(getPosition()));
      setIndex(omitEnd ? min(index, endIndex) : index);
      callback && callback();
    });
  }
  function parse(control) {
    var index = currIndex;
    if (isString(control)) {
      var _ref = control.match(/([+\-<>])(\d+)?/) || [], indicator = _ref[1], number = _ref[2];
      if (indicator === "+" || indicator === "-") {
        index = computeDestIndex(currIndex + +("" + indicator + (+number || 1)), currIndex);
      } else if (indicator === ">") {
        index = number ? toIndex(+number) : getNext(true);
      } else if (indicator === "<") {
        index = getPrev(true);
      }
    } else {
      index = isLoop ? control : clamp(control, 0, endIndex);
    }
    return index;
  }
  function getAdjacent(prev, destination) {
    var number = perMove || (hasFocus() ? 1 : perPage);
    var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));
    if (dest === -1 && isSlide) {
      if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {
        return prev ? 0 : endIndex;
      }
    }
    return destination ? dest : loop(dest);
  }
  function computeDestIndex(dest, from, snapPage) {
    if (isEnough() || hasFocus()) {
      var index = computeMovableDestIndex(dest);
      if (index !== dest) {
        from = dest;
        dest = index;
        snapPage = false;
      }
      if (dest < 0 || dest > endIndex) {
        if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) {
          dest = toIndex(toPage(dest));
        } else {
          if (isLoop) {
            dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;
          } else if (options.rewind) {
            dest = dest < 0 ? endIndex : 0;
          } else {
            dest = -1;
          }
        }
      } else {
        if (snapPage && dest !== from) {
          dest = toIndex(toPage(from) + (dest < from ? -1 : 1));
        }
      }
    } else {
      dest = -1;
    }
    return dest;
  }
  function computeMovableDestIndex(dest) {
    if (isSlide && options.trimSpace === "move" && dest !== currIndex) {
      var position = getPosition();
      while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) {
        dest < currIndex ? --dest : ++dest;
      }
    }
    return dest;
  }
  function loop(index) {
    return isLoop ? (index + slideCount) % slideCount || 0 : index;
  }
  function getEnd() {
    var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);
    while (omitEnd && end-- > 0) {
      if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {
        end++;
        break;
      }
    }
    return clamp(end, 0, slideCount - 1);
  }
  function toIndex(page) {
    return clamp(hasFocus() ? page : perPage * page, 0, endIndex);
  }
  function toPage(index) {
    return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);
  }
  function toDest(destination) {
    var closest2 = Move2.toIndex(destination);
    return isSlide ? clamp(closest2, 0, endIndex) : closest2;
  }
  function setIndex(index) {
    if (index !== currIndex) {
      prevIndex = currIndex;
      currIndex = index;
    }
  }
  function getIndex(prev) {
    return prev ? prevIndex : currIndex;
  }
  function hasFocus() {
    return !isUndefined(options.focus) || options.isNavigation;
  }
  function isBusy() {
    return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition;
  }
  return {
    mount,
    go,
    scroll,
    getNext,
    getPrev,
    getAdjacent,
    getEnd,
    setIndex,
    getIndex,
    toIndex,
    toPage,
    toDest,
    hasFocus,
    isBusy
  };
}
var XML_NAME_SPACE = "http://www.w3.org/2000/svg";
var PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
var SIZE = 40;
function Arrows(Splide2, Components2, options) {
  var event = EventInterface(Splide2);
  var on = event.on, bind2 = event.bind, emit = event.emit;
  var classes = options.classes, i18n = options.i18n;
  var Elements2 = Components2.Elements, Controller2 = Components2.Controller;
  var placeholder = Elements2.arrows, track = Elements2.track;
  var wrapper = placeholder;
  var prev = Elements2.prev;
  var next = Elements2.next;
  var created;
  var wrapperClasses;
  var arrows = {};
  function mount() {
    init2();
    on(EVENT_UPDATED, remount);
  }
  function remount() {
    destroy();
    mount();
  }
  function init2() {
    var enabled = options.arrows;
    if (enabled && !(prev && next)) {
      createArrows();
    }
    if (prev && next) {
      assign2(arrows, {
        prev,
        next
      });
      display(wrapper, enabled ? "" : "none");
      addClass(wrapper, wrapperClasses = CLASS_ARROWS + "--" + options.direction);
      if (enabled) {
        listen();
        update();
        setAttribute([prev, next], ARIA_CONTROLS, track.id);
        emit(EVENT_ARROWS_MOUNTED, prev, next);
      }
    }
  }
  function destroy() {
    event.destroy();
    removeClass(wrapper, wrapperClasses);
    if (created) {
      remove(placeholder ? [prev, next] : wrapper);
      prev = next = null;
    } else {
      removeAttribute([prev, next], ALL_ATTRIBUTES);
    }
  }
  function listen() {
    on([EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED], update);
    bind2(next, "click", apply(go, ">"));
    bind2(prev, "click", apply(go, "<"));
  }
  function go(control) {
    Controller2.go(control, true);
  }
  function createArrows() {
    wrapper = placeholder || create("div", classes.arrows);
    prev = createArrow(true);
    next = createArrow(false);
    created = true;
    append(wrapper, [prev, next]);
    !placeholder && before(wrapper, track);
  }
  function createArrow(prev2) {
    var arrow = '<button class="' + classes.arrow + " " + (prev2 ? classes.prev : classes.next) + '" type="button"><svg xmlns="' + XML_NAME_SPACE + '" viewBox="0 0 ' + SIZE + " " + SIZE + '" width="' + SIZE + '" height="' + SIZE + '" focusable="false"><path d="' + (options.arrowPath || PATH) + '" />';
    return parseHtml(arrow);
  }
  function update() {
    if (prev && next) {
      var index = Splide2.index;
      var prevIndex = Controller2.getPrev();
      var nextIndex = Controller2.getNext();
      var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
      var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
      prev.disabled = prevIndex < 0;
      next.disabled = nextIndex < 0;
      setAttribute(prev, ARIA_LABEL, prevLabel);
      setAttribute(next, ARIA_LABEL, nextLabel);
      emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);
    }
  }
  return {
    arrows,
    mount,
    destroy,
    update
  };
}
var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-interval";
function Autoplay(Splide2, Components2, options) {
  var _EventInterface6 = EventInterface(Splide2), on = _EventInterface6.on, bind2 = _EventInterface6.bind, emit = _EventInterface6.emit;
  var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), onAnimationFrame);
  var isPaused = interval.isPaused;
  var Elements2 = Components2.Elements, _Components2$Elements4 = Components2.Elements, root = _Components2$Elements4.root, toggle = _Components2$Elements4.toggle;
  var autoplay = options.autoplay;
  var hovered;
  var focused;
  var stopped = autoplay === "pause";
  function mount() {
    if (autoplay) {
      listen();
      toggle && setAttribute(toggle, ARIA_CONTROLS, Elements2.track.id);
      stopped || play();
      update();
    }
  }
  function listen() {
    if (options.pauseOnHover) {
      bind2(root, "mouseenter mouseleave", function(e) {
        hovered = e.type === "mouseenter";
        autoToggle();
      });
    }
    if (options.pauseOnFocus) {
      bind2(root, "focusin focusout", function(e) {
        focused = e.type === "focusin";
        autoToggle();
      });
    }
    if (toggle) {
      bind2(toggle, "click", function() {
        stopped ? play() : pause(true);
      });
    }
    on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);
    on(EVENT_MOVE, onMove);
  }
  function play() {
    if (isPaused() && Components2.Slides.isEnough()) {
      interval.start(!options.resetProgress);
      focused = hovered = stopped = false;
      update();
      emit(EVENT_AUTOPLAY_PLAY);
    }
  }
  function pause(stop) {
    if (stop === void 0) {
      stop = true;
    }
    stopped = !!stop;
    update();
    if (!isPaused()) {
      interval.pause();
      emit(EVENT_AUTOPLAY_PAUSE);
    }
  }
  function autoToggle() {
    if (!stopped) {
      hovered || focused ? pause(false) : play();
    }
  }
  function update() {
    if (toggle) {
      toggleClass(toggle, CLASS_ACTIVE, !stopped);
      setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? "play" : "pause"]);
    }
  }
  function onAnimationFrame(rate) {
    var bar = Elements2.bar;
    bar && style(bar, "width", rate * 100 + "%");
    emit(EVENT_AUTOPLAY_PLAYING, rate);
  }
  function onMove(index) {
    var Slide2 = Components2.Slides.getAt(index);
    interval.set(Slide2 && +getAttribute(Slide2.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);
  }
  return {
    mount,
    destroy: interval.cancel,
    play,
    pause,
    isPaused
  };
}
function Cover(Splide2, Components2, options) {
  var _EventInterface7 = EventInterface(Splide2), on = _EventInterface7.on;
  function mount() {
    if (options.cover) {
      on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));
      on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, true));
    }
  }
  function cover(cover2) {
    Components2.Slides.forEach(function(Slide2) {
      var img = child(Slide2.container || Slide2.slide, "img");
      if (img && img.src) {
        toggle(cover2, img, Slide2);
      }
    });
  }
  function toggle(cover2, img, Slide2) {
    Slide2.style("background", cover2 ? 'center/cover no-repeat url("' + img.src + '")' : "", true);
    display(img, cover2 ? "none" : "");
  }
  return {
    mount,
    destroy: apply(cover, false)
  };
}
var BOUNCE_DIFF_THRESHOLD = 10;
var BOUNCE_DURATION = 600;
var FRICTION_FACTOR = 0.6;
var BASE_VELOCITY = 1.5;
var MIN_DURATION = 800;
function Scroll(Splide2, Components2, options) {
  var _EventInterface8 = EventInterface(Splide2), on = _EventInterface8.on, emit = _EventInterface8.emit;
  var set = Splide2.state.set;
  var Move2 = Components2.Move;
  var getPosition = Move2.getPosition, getLimit = Move2.getLimit, exceededLimit = Move2.exceededLimit, translate = Move2.translate;
  var isSlide = Splide2.is(SLIDE);
  var interval;
  var callback;
  var friction = 1;
  function mount() {
    on(EVENT_MOVE, clear);
    on([EVENT_UPDATED, EVENT_REFRESH], cancel);
  }
  function scroll(destination, duration, snap, onScrolled, noConstrain) {
    var from = getPosition();
    clear();
    if (snap && (!isSlide || !exceededLimit())) {
      var size = Components2.Layout.sliderSize();
      var offset = sign(destination) * size * floor(abs(destination) / size) || 0;
      destination = Move2.toPosition(Components2.Controller.toDest(destination % size)) + offset;
    }
    var noDistance = approximatelyEqual(from, destination, 1);
    friction = 1;
    duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);
    callback = onScrolled;
    interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);
    set(SCROLLING);
    emit(EVENT_SCROLL);
    interval.start();
  }
  function onEnd() {
    set(IDLE);
    callback && callback();
    emit(EVENT_SCROLLED);
  }
  function update(from, to, noConstrain, rate) {
    var position = getPosition();
    var target = from + (to - from) * easing(rate);
    var diff = (target - position) * friction;
    translate(position + diff);
    if (isSlide && !noConstrain && exceededLimit()) {
      friction *= FRICTION_FACTOR;
      if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {
        scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);
      }
    }
  }
  function clear() {
    if (interval) {
      interval.cancel();
    }
  }
  function cancel() {
    if (interval && !interval.isPaused()) {
      clear();
      onEnd();
    }
  }
  function easing(t) {
    var easingFunc = options.easingFunc;
    return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);
  }
  return {
    mount,
    destroy: clear,
    scroll,
    cancel
  };
}
var SCROLL_LISTENER_OPTIONS = {
  passive: false,
  capture: true
};
function Drag(Splide2, Components2, options) {
  var _EventInterface9 = EventInterface(Splide2), on = _EventInterface9.on, emit = _EventInterface9.emit, bind2 = _EventInterface9.bind, unbind = _EventInterface9.unbind;
  var state = Splide2.state;
  var Move2 = Components2.Move, Scroll2 = Components2.Scroll, Controller2 = Components2.Controller, track = Components2.Elements.track, reduce = Components2.Media.reduce;
  var _Components2$Directio2 = Components2.Direction, resolve = _Components2$Directio2.resolve, orient = _Components2$Directio2.orient;
  var getPosition = Move2.getPosition, exceededLimit = Move2.exceededLimit;
  var basePosition;
  var baseEvent;
  var prevBaseEvent;
  var isFree;
  var dragging;
  var exceeded = false;
  var clickPrevented;
  var disabled;
  var target;
  function mount() {
    bind2(track, POINTER_MOVE_EVENTS, noop2, SCROLL_LISTENER_OPTIONS);
    bind2(track, POINTER_UP_EVENTS, noop2, SCROLL_LISTENER_OPTIONS);
    bind2(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
    bind2(track, "click", onClick, {
      capture: true
    });
    bind2(track, "dragstart", prevent);
    on([EVENT_MOUNTED, EVENT_UPDATED], init2);
  }
  function init2() {
    var drag = options.drag;
    disable(!drag);
    isFree = drag === "free";
  }
  function onPointerDown(e) {
    clickPrevented = false;
    if (!disabled) {
      var isTouch = isTouchEvent(e);
      if (isDraggable(e.target) && (isTouch || !e.button)) {
        if (!Controller2.isBusy()) {
          target = isTouch ? track : window;
          dragging = state.is([MOVING, SCROLLING]);
          prevBaseEvent = null;
          bind2(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
          bind2(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
          Move2.cancel();
          Scroll2.cancel();
          save(e);
        } else {
          prevent(e, true);
        }
      }
    }
  }
  function onPointerMove(e) {
    if (!state.is(DRAGGING)) {
      state.set(DRAGGING);
      emit(EVENT_DRAG);
    }
    if (e.cancelable) {
      if (dragging) {
        Move2.translate(basePosition + constrain(diffCoord(e)));
        var expired = diffTime(e) > LOG_INTERVAL;
        var hasExceeded = exceeded !== (exceeded = exceededLimit());
        if (expired || hasExceeded) {
          save(e);
        }
        clickPrevented = true;
        emit(EVENT_DRAGGING);
        prevent(e);
      } else if (isSliderDirection(e)) {
        dragging = shouldStart(e);
        prevent(e);
      }
    }
  }
  function onPointerUp(e) {
    if (state.is(DRAGGING)) {
      state.set(IDLE);
      emit(EVENT_DRAGGED);
    }
    if (dragging) {
      move(e);
      prevent(e);
    }
    unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
    unbind(target, POINTER_UP_EVENTS, onPointerUp);
    dragging = false;
  }
  function onClick(e) {
    if (!disabled && clickPrevented) {
      prevent(e, true);
    }
  }
  function save(e) {
    prevBaseEvent = baseEvent;
    baseEvent = e;
    basePosition = getPosition();
  }
  function move(e) {
    var velocity = computeVelocity(e);
    var destination = computeDestination(velocity);
    var rewind = options.rewind && options.rewindByDrag;
    reduce(false);
    if (isFree) {
      Controller2.scroll(destination, 0, options.snap);
    } else if (Splide2.is(FADE)) {
      Controller2.go(orient(sign(velocity)) < 0 ? rewind ? "<" : "-" : rewind ? ">" : "+");
    } else if (Splide2.is(SLIDE) && exceeded && rewind) {
      Controller2.go(exceededLimit(true) ? ">" : "<");
    } else {
      Controller2.go(Controller2.toDest(destination), true);
    }
    reduce(true);
  }
  function shouldStart(e) {
    var thresholds = options.dragMinThreshold;
    var isObj = isObject2(thresholds);
    var mouse = isObj && thresholds.mouse || 0;
    var touch = (isObj ? thresholds.touch : +thresholds) || 10;
    return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);
  }
  function isSliderDirection(e) {
    return abs(diffCoord(e)) > abs(diffCoord(e, true));
  }
  function computeVelocity(e) {
    if (Splide2.is(LOOP) || !exceeded) {
      var time = diffTime(e);
      if (time && time < LOG_INTERVAL) {
        return diffCoord(e) / time;
      }
    }
    return 0;
  }
  function computeDestination(velocity) {
    return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));
  }
  function diffCoord(e, orthogonal) {
    return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);
  }
  function diffTime(e) {
    return timeOf(e) - timeOf(getBaseEvent(e));
  }
  function getBaseEvent(e) {
    return baseEvent === e && prevBaseEvent || baseEvent;
  }
  function coordOf(e, orthogonal) {
    return (isTouchEvent(e) ? e.changedTouches[0] : e)["page" + resolve(orthogonal ? "Y" : "X")];
  }
  function constrain(diff) {
    return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);
  }
  function isDraggable(target2) {
    var noDrag = options.noDrag;
    return !matches(target2, "." + CLASS_PAGINATION_PAGE + ", ." + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));
  }
  function isTouchEvent(e) {
    return typeof TouchEvent !== "undefined" && e instanceof TouchEvent;
  }
  function isDragging() {
    return dragging;
  }
  function disable(value) {
    disabled = value;
  }
  return {
    mount,
    disable,
    isDragging
  };
}
var NORMALIZATION_MAP = {
  Spacebar: " ",
  Right: ARROW_RIGHT,
  Left: ARROW_LEFT,
  Up: ARROW_UP,
  Down: ARROW_DOWN
};
function normalizeKey(key) {
  key = isString(key) ? key : key.key;
  return NORMALIZATION_MAP[key] || key;
}
var KEYBOARD_EVENT = "keydown";
function Keyboard(Splide2, Components2, options) {
  var _EventInterface10 = EventInterface(Splide2), on = _EventInterface10.on, bind2 = _EventInterface10.bind, unbind = _EventInterface10.unbind;
  var root = Splide2.root;
  var resolve = Components2.Direction.resolve;
  var target;
  var disabled;
  function mount() {
    init2();
    on(EVENT_UPDATED, destroy);
    on(EVENT_UPDATED, init2);
    on(EVENT_MOVE, onMove);
  }
  function init2() {
    var keyboard = options.keyboard;
    if (keyboard) {
      target = keyboard === "global" ? window : root;
      bind2(target, KEYBOARD_EVENT, onKeydown);
    }
  }
  function destroy() {
    unbind(target, KEYBOARD_EVENT);
  }
  function disable(value) {
    disabled = value;
  }
  function onMove() {
    var _disabled = disabled;
    disabled = true;
    nextTick(function() {
      disabled = _disabled;
    });
  }
  function onKeydown(e) {
    if (!disabled) {
      var key = normalizeKey(e);
      if (key === resolve(ARROW_LEFT)) {
        Splide2.go("<");
      } else if (key === resolve(ARROW_RIGHT)) {
        Splide2.go(">");
      }
    }
  }
  return {
    mount,
    destroy,
    disable
  };
}
var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-lazy";
var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + "-srcset";
var IMAGE_SELECTOR = "[" + SRC_DATA_ATTRIBUTE + "], [" + SRCSET_DATA_ATTRIBUTE + "]";
function LazyLoad(Splide2, Components2, options) {
  var _EventInterface11 = EventInterface(Splide2), on = _EventInterface11.on, off = _EventInterface11.off, bind2 = _EventInterface11.bind, emit = _EventInterface11.emit;
  var isSequential = options.lazyLoad === "sequential";
  var events = [EVENT_MOVED, EVENT_SCROLLED];
  var entries = [];
  function mount() {
    if (options.lazyLoad) {
      init2();
      on(EVENT_REFRESH, init2);
    }
  }
  function init2() {
    empty2(entries);
    register();
    if (isSequential) {
      loadNext();
    } else {
      off(events);
      on(events, check);
      check();
    }
  }
  function register() {
    Components2.Slides.forEach(function(Slide2) {
      queryAll(Slide2.slide, IMAGE_SELECTOR).forEach(function(img) {
        var src = getAttribute(img, SRC_DATA_ATTRIBUTE);
        var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);
        if (src !== img.src || srcset !== img.srcset) {
          var className = options.classes.spinner;
          var parent = img.parentElement;
          var spinner = child(parent, "." + className) || create("span", className, parent);
          entries.push([img, Slide2, spinner]);
          img.src || display(img, "none");
        }
      });
    });
  }
  function check() {
    entries = entries.filter(function(data) {
      var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
      return data[1].isWithin(Splide2.index, distance) ? load(data) : true;
    });
    entries.length || off(events);
  }
  function load(data) {
    var img = data[0];
    addClass(data[1].slide, CLASS_LOADING);
    bind2(img, "load error", apply(onLoad, data));
    setAttribute(img, "src", getAttribute(img, SRC_DATA_ATTRIBUTE));
    setAttribute(img, "srcset", getAttribute(img, SRCSET_DATA_ATTRIBUTE));
    removeAttribute(img, SRC_DATA_ATTRIBUTE);
    removeAttribute(img, SRCSET_DATA_ATTRIBUTE);
  }
  function onLoad(data, e) {
    var img = data[0], Slide2 = data[1];
    removeClass(Slide2.slide, CLASS_LOADING);
    if (e.type !== "error") {
      remove(data[2]);
      display(img, "");
      emit(EVENT_LAZYLOAD_LOADED, img, Slide2);
      emit(EVENT_RESIZE);
    }
    isSequential && loadNext();
  }
  function loadNext() {
    entries.length && load(entries.shift());
  }
  return {
    mount,
    destroy: apply(empty2, entries),
    check
  };
}
function Pagination(Splide2, Components2, options) {
  var event = EventInterface(Splide2);
  var on = event.on, emit = event.emit, bind2 = event.bind;
  var Slides2 = Components2.Slides, Elements2 = Components2.Elements, Controller2 = Components2.Controller;
  var hasFocus = Controller2.hasFocus, getIndex = Controller2.getIndex, go = Controller2.go;
  var resolve = Components2.Direction.resolve;
  var placeholder = Elements2.pagination;
  var items = [];
  var list;
  var paginationClasses;
  function mount() {
    destroy();
    on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], mount);
    var enabled = options.pagination;
    placeholder && display(placeholder, enabled ? "" : "none");
    if (enabled) {
      on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);
      createPagination();
      update();
      emit(EVENT_PAGINATION_MOUNTED, {
        list,
        items
      }, getAt(Splide2.index));
    }
  }
  function destroy() {
    if (list) {
      remove(placeholder ? slice(list.children) : list);
      removeClass(list, paginationClasses);
      empty2(items);
      list = null;
    }
    event.destroy();
  }
  function createPagination() {
    var length = Splide2.length;
    var classes = options.classes, i18n = options.i18n, perPage = options.perPage;
    var max2 = hasFocus() ? Controller2.getEnd() + 1 : ceil(length / perPage);
    list = placeholder || create("ul", classes.pagination, Elements2.track.parentElement);
    addClass(list, paginationClasses = CLASS_PAGINATION + "--" + getDirection());
    setAttribute(list, ROLE, "tablist");
    setAttribute(list, ARIA_LABEL, i18n.select);
    setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? "vertical" : "");
    for (var i = 0; i < max2; i++) {
      var li = create("li", null, list);
      var button = create("button", {
        class: classes.page,
        type: "button"
      }, li);
      var controls = Slides2.getIn(i).map(function(Slide2) {
        return Slide2.slide.id;
      });
      var text2 = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
      bind2(button, "click", apply(onClick, i));
      if (options.paginationKeyboard) {
        bind2(button, "keydown", apply(onKeydown, i));
      }
      setAttribute(li, ROLE, "presentation");
      setAttribute(button, ROLE, "tab");
      setAttribute(button, ARIA_CONTROLS, controls.join(" "));
      setAttribute(button, ARIA_LABEL, format(text2, i + 1));
      setAttribute(button, TAB_INDEX, -1);
      items.push({
        li,
        button,
        page: i
      });
    }
  }
  function onClick(page) {
    go(">" + page, true);
  }
  function onKeydown(page, e) {
    var length = items.length;
    var key = normalizeKey(e);
    var dir = getDirection();
    var nextPage = -1;
    if (key === resolve(ARROW_RIGHT, false, dir)) {
      nextPage = ++page % length;
    } else if (key === resolve(ARROW_LEFT, false, dir)) {
      nextPage = (--page + length) % length;
    } else if (key === "Home") {
      nextPage = 0;
    } else if (key === "End") {
      nextPage = length - 1;
    }
    var item = items[nextPage];
    if (item) {
      focus(item.button);
      go(">" + nextPage);
      prevent(e, true);
    }
  }
  function getDirection() {
    return options.paginationDirection || options.direction;
  }
  function getAt(index) {
    return items[Controller2.toPage(index)];
  }
  function update() {
    var prev = getAt(getIndex(true));
    var curr = getAt(getIndex());
    if (prev) {
      var button = prev.button;
      removeClass(button, CLASS_ACTIVE);
      removeAttribute(button, ARIA_SELECTED);
      setAttribute(button, TAB_INDEX, -1);
    }
    if (curr) {
      var _button = curr.button;
      addClass(_button, CLASS_ACTIVE);
      setAttribute(_button, ARIA_SELECTED, true);
      setAttribute(_button, TAB_INDEX, "");
    }
    emit(EVENT_PAGINATION_UPDATED, {
      list,
      items
    }, prev, curr);
  }
  return {
    items,
    mount,
    destroy,
    getAt,
    update
  };
}
var TRIGGER_KEYS = [" ", "Enter"];
function Sync(Splide2, Components2, options) {
  var isNavigation = options.isNavigation, slideFocus = options.slideFocus;
  var events = [];
  function mount() {
    Splide2.splides.forEach(function(target) {
      if (!target.isParent) {
        sync(Splide2, target.splide);
        sync(target.splide, Splide2);
      }
    });
    if (isNavigation) {
      navigate();
    }
  }
  function destroy() {
    events.forEach(function(event) {
      event.destroy();
    });
    empty2(events);
  }
  function remount() {
    destroy();
    mount();
  }
  function sync(splide, target) {
    var event = EventInterface(splide);
    event.on(EVENT_MOVE, function(index, prev, dest) {
      target.go(target.is(LOOP) ? dest : index);
    });
    events.push(event);
  }
  function navigate() {
    var event = EventInterface(Splide2);
    var on = event.on;
    on(EVENT_CLICK, onClick);
    on(EVENT_SLIDE_KEYDOWN, onKeydown);
    on([EVENT_MOUNTED, EVENT_UPDATED], update);
    events.push(event);
    event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);
  }
  function update() {
    setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? "vertical" : "");
  }
  function onClick(Slide2) {
    Splide2.go(Slide2.index);
  }
  function onKeydown(Slide2, e) {
    if (includes(TRIGGER_KEYS, normalizeKey(e))) {
      onClick(Slide2);
      prevent(e);
    }
  }
  return {
    setup: apply(Components2.Media.set, {
      slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus
    }, true),
    mount,
    destroy,
    remount
  };
}
function Wheel(Splide2, Components2, options) {
  var _EventInterface12 = EventInterface(Splide2), bind2 = _EventInterface12.bind;
  var lastTime = 0;
  function mount() {
    if (options.wheel) {
      bind2(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS);
    }
  }
  function onWheel(e) {
    if (e.cancelable) {
      var deltaY = e.deltaY;
      var backwards = deltaY < 0;
      var timeStamp = timeOf(e);
      var _min = options.wheelMinThreshold || 0;
      var sleep = options.wheelSleep || 0;
      if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {
        Splide2.go(backwards ? "<" : ">");
        lastTime = timeStamp;
      }
      shouldPrevent(backwards) && prevent(e);
    }
  }
  function shouldPrevent(backwards) {
    return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;
  }
  return {
    mount
  };
}
var SR_REMOVAL_DELAY = 90;
function Live(Splide2, Components2, options) {
  var _EventInterface13 = EventInterface(Splide2), on = _EventInterface13.on;
  var track = Components2.Elements.track;
  var enabled = options.live && !options.isNavigation;
  var sr = create("span", CLASS_SR);
  var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));
  function mount() {
    if (enabled) {
      disable(!Components2.Autoplay.isPaused());
      setAttribute(track, ARIA_ATOMIC, true);
      sr.textContent = "…";
      on(EVENT_AUTOPLAY_PLAY, apply(disable, true));
      on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));
      on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, true));
    }
  }
  function toggle(active) {
    setAttribute(track, ARIA_BUSY, active);
    if (active) {
      append(track, sr);
      interval.start();
    } else {
      remove(sr);
      interval.cancel();
    }
  }
  function destroy() {
    removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);
    remove(sr);
  }
  function disable(disabled) {
    if (enabled) {
      setAttribute(track, ARIA_LIVE, disabled ? "off" : "polite");
    }
  }
  return {
    mount,
    disable,
    destroy
  };
}
var ComponentConstructors = Object.freeze({
  __proto__: null,
  Media,
  Direction,
  Elements,
  Slides,
  Layout,
  Clones,
  Move,
  Controller,
  Arrows,
  Autoplay,
  Cover,
  Scroll,
  Drag,
  Keyboard,
  LazyLoad,
  Pagination,
  Sync,
  Wheel,
  Live
});
var I18N = {
  prev: "Previous slide",
  next: "Next slide",
  first: "Go to first slide",
  last: "Go to last slide",
  slideX: "Go to slide %s",
  pageX: "Go to page %s",
  play: "Start autoplay",
  pause: "Pause autoplay",
  carousel: "carousel",
  slide: "slide",
  select: "Select a slide to show",
  slideLabel: "%s of %s"
};
var DEFAULTS = {
  type: "slide",
  role: "region",
  speed: 400,
  perPage: 1,
  cloneStatus: true,
  arrows: true,
  pagination: true,
  paginationKeyboard: true,
  interval: 5e3,
  pauseOnHover: true,
  pauseOnFocus: true,
  resetProgress: true,
  easing: "cubic-bezier(0.25, 1, 0.5, 1)",
  drag: true,
  direction: "ltr",
  trimSpace: true,
  focusableNodes: "a, button, textarea, input, select, iframe",
  live: true,
  classes: CLASSES,
  i18n: I18N,
  reducedMotion: {
    speed: 0,
    rewindSpeed: 0,
    autoplay: "pause"
  }
};
function Fade(Splide2, Components2, options) {
  var Slides2 = Components2.Slides;
  function mount() {
    EventInterface(Splide2).on([EVENT_MOUNTED, EVENT_REFRESH], init2);
  }
  function init2() {
    Slides2.forEach(function(Slide2) {
      Slide2.style("transform", "translateX(-" + 100 * Slide2.index + "%)");
    });
  }
  function start(index, done) {
    Slides2.style("transition", "opacity " + options.speed + "ms " + options.easing);
    nextTick(done);
  }
  return {
    mount,
    start,
    cancel: noop2
  };
}
function Slide(Splide2, Components2, options) {
  var Move2 = Components2.Move, Controller2 = Components2.Controller, Scroll2 = Components2.Scroll;
  var list = Components2.Elements.list;
  var transition = apply(style, list, "transition");
  var endCallback;
  function mount() {
    EventInterface(Splide2).bind(list, "transitionend", function(e) {
      if (e.target === list && endCallback) {
        cancel();
        endCallback();
      }
    });
  }
  function start(index, done) {
    var destination = Move2.toPosition(index, true);
    var position = Move2.getPosition();
    var speed = getSpeed(index);
    if (abs(destination - position) >= 1 && speed >= 1) {
      if (options.useScroll) {
        Scroll2.scroll(destination, speed, false, done);
      } else {
        transition("transform " + speed + "ms " + options.easing);
        Move2.translate(destination, true);
        endCallback = done;
      }
    } else {
      Move2.jump(index);
      done();
    }
  }
  function cancel() {
    transition("");
    Scroll2.cancel();
  }
  function getSpeed(index) {
    var rewindSpeed = options.rewindSpeed;
    if (Splide2.is(SLIDE) && rewindSpeed) {
      var prev = Controller2.getIndex(true);
      var end = Controller2.getEnd();
      if (prev === 0 && index >= end || prev >= end && index === 0) {
        return rewindSpeed;
      }
    }
    return options.speed;
  }
  return {
    mount,
    start,
    cancel
  };
}
var _Splide = function() {
  function _Splide2(target, options) {
    this.event = EventInterface();
    this.Components = {};
    this.state = State(CREATED);
    this.splides = [];
    this._o = {};
    this._E = {};
    var root = isString(target) ? query(document, target) : target;
    assert(root, root + " is invalid.");
    this.root = root;
    options = merge2({
      label: getAttribute(root, ARIA_LABEL) || "",
      labelledby: getAttribute(root, ARIA_LABELLEDBY) || ""
    }, DEFAULTS, _Splide2.defaults, options || {});
    try {
      merge2(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));
    } catch (e) {
      assert(false, "Invalid JSON");
    }
    this._o = Object.create(merge2({}, options));
  }
  var _proto = _Splide2.prototype;
  _proto.mount = function mount(Extensions, Transition) {
    var _this = this;
    var state = this.state, Components2 = this.Components;
    assert(state.is([CREATED, DESTROYED]), "Already mounted!");
    state.set(CREATED);
    this._C = Components2;
    this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);
    this._E = Extensions || this._E;
    var Constructors = assign2({}, ComponentConstructors, this._E, {
      Transition: this._T
    });
    forOwn2(Constructors, function(Component, key) {
      var component = Component(_this, Components2, _this._o);
      Components2[key] = component;
      component.setup && component.setup();
    });
    forOwn2(Components2, function(component) {
      component.mount && component.mount();
    });
    this.emit(EVENT_MOUNTED);
    addClass(this.root, CLASS_INITIALIZED);
    state.set(IDLE);
    this.emit(EVENT_READY);
    return this;
  };
  _proto.sync = function sync(splide) {
    this.splides.push({
      splide
    });
    splide.splides.push({
      splide: this,
      isParent: true
    });
    if (this.state.is(IDLE)) {
      this._C.Sync.remount();
      splide.Components.Sync.remount();
    }
    return this;
  };
  _proto.go = function go(control) {
    this._C.Controller.go(control);
    return this;
  };
  _proto.on = function on(events, callback) {
    this.event.on(events, callback);
    return this;
  };
  _proto.off = function off(events) {
    this.event.off(events);
    return this;
  };
  _proto.emit = function emit(event) {
    var _this$event;
    (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));
    return this;
  };
  _proto.add = function add(slides, index) {
    this._C.Slides.add(slides, index);
    return this;
  };
  _proto.remove = function remove2(matcher) {
    this._C.Slides.remove(matcher);
    return this;
  };
  _proto.is = function is(type) {
    return this._o.type === type;
  };
  _proto.refresh = function refresh() {
    this.emit(EVENT_REFRESH);
    return this;
  };
  _proto.destroy = function destroy(completely) {
    if (completely === void 0) {
      completely = true;
    }
    var event = this.event, state = this.state;
    if (state.is(CREATED)) {
      EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));
    } else {
      forOwn2(this._C, function(component) {
        component.destroy && component.destroy(completely);
      }, true);
      event.emit(EVENT_DESTROY);
      event.destroy();
      completely && empty2(this.splides);
      state.set(DESTROYED);
    }
    return this;
  };
  _createClass(_Splide2, [{
    key: "options",
    get: function get() {
      return this._o;
    },
    set: function set(options) {
      this._C.Media.set(options, true, true);
    }
  }, {
    key: "length",
    get: function get() {
      return this._C.Slides.getLength(true);
    }
  }, {
    key: "index",
    get: function get() {
      return this._C.Controller.getIndex();
    }
  }]);
  return _Splide2;
}();
var Splide = _Splide;
Splide.defaults = {};
Splide.STATES = STATES;
var CLASS_RENDERED = "is-rendered";
var RENDERER_DEFAULT_CONFIG = {
  listTag: "ul",
  slideTag: "li"
};
var Style = function() {
  function Style2(id, options) {
    this.styles = {};
    this.id = id;
    this.options = options;
  }
  var _proto2 = Style2.prototype;
  _proto2.rule = function rule(selector, prop, value, breakpoint) {
    breakpoint = breakpoint || "default";
    var selectors = this.styles[breakpoint] = this.styles[breakpoint] || {};
    var styles = selectors[selector] = selectors[selector] || {};
    styles[prop] = value;
  };
  _proto2.build = function build() {
    var _this2 = this;
    var css = "";
    if (this.styles.default) {
      css += this.buildSelectors(this.styles.default);
    }
    Object.keys(this.styles).sort(function(n, m) {
      return _this2.options.mediaQuery === "min" ? +n - +m : +m - +n;
    }).forEach(function(breakpoint) {
      if (breakpoint !== "default") {
        css += "@media screen and (max-width: " + breakpoint + "px) {";
        css += _this2.buildSelectors(_this2.styles[breakpoint]);
        css += "}";
      }
    });
    return css;
  };
  _proto2.buildSelectors = function buildSelectors(selectors) {
    var _this3 = this;
    var css = "";
    forOwn2(selectors, function(styles, selector) {
      selector = ("#" + _this3.id + " " + selector).trim();
      css += selector + " {";
      forOwn2(styles, function(value, prop) {
        if (value || value === 0) {
          css += prop + ": " + value + ";";
        }
      });
      css += "}";
    });
    return css;
  };
  return Style2;
}();
var SplideRenderer = function() {
  function SplideRenderer2(contents, options, config, defaults) {
    this.slides = [];
    this.options = {};
    this.breakpoints = [];
    merge2(DEFAULTS, defaults || {});
    merge2(merge2(this.options, DEFAULTS), options || {});
    this.contents = contents;
    this.config = assign2({}, RENDERER_DEFAULT_CONFIG, config || {});
    this.id = this.config.id || uniqueId("splide");
    this.Style = new Style(this.id, this.options);
    this.Direction = Direction(null, null, this.options);
    assert(this.contents.length, "Provide at least 1 content.");
    this.init();
  }
  SplideRenderer2.clean = function clean(splide) {
    var _EventInterface14 = EventInterface(splide), on = _EventInterface14.on;
    var root = splide.root;
    var clones = queryAll(root, "." + CLASS_CLONE);
    on(EVENT_MOUNTED, function() {
      remove(child(root, "style"));
    });
    remove(clones);
  };
  var _proto3 = SplideRenderer2.prototype;
  _proto3.init = function init2() {
    this.parseBreakpoints();
    this.initSlides();
    this.registerRootStyles();
    this.registerTrackStyles();
    this.registerSlideStyles();
    this.registerListStyles();
  };
  _proto3.initSlides = function initSlides() {
    var _this4 = this;
    push(this.slides, this.contents.map(function(content, index) {
      content = isString(content) ? {
        html: content
      } : content;
      content.styles = content.styles || {};
      content.attrs = content.attrs || {};
      _this4.cover(content);
      var classes = _this4.options.classes.slide + " " + (index === 0 ? CLASS_ACTIVE : "");
      assign2(content.attrs, {
        class: (classes + " " + (content.attrs.class || "")).trim(),
        style: _this4.buildStyles(content.styles)
      });
      return content;
    }));
    if (this.isLoop()) {
      this.generateClones(this.slides);
    }
  };
  _proto3.registerRootStyles = function registerRootStyles() {
    var _this5 = this;
    this.breakpoints.forEach(function(_ref2) {
      var width = _ref2[0], options = _ref2[1];
      _this5.Style.rule(" ", "max-width", unit(options.width), width);
    });
  };
  _proto3.registerTrackStyles = function registerTrackStyles() {
    var _this6 = this;
    var Style2 = this.Style;
    var selector = "." + CLASS_TRACK;
    this.breakpoints.forEach(function(_ref3) {
      var width = _ref3[0], options = _ref3[1];
      Style2.rule(selector, _this6.resolve("paddingLeft"), _this6.cssPadding(options, false), width);
      Style2.rule(selector, _this6.resolve("paddingRight"), _this6.cssPadding(options, true), width);
      Style2.rule(selector, "height", _this6.cssTrackHeight(options), width);
    });
  };
  _proto3.registerListStyles = function registerListStyles() {
    var _this7 = this;
    var Style2 = this.Style;
    var selector = "." + CLASS_LIST;
    this.breakpoints.forEach(function(_ref4) {
      var width = _ref4[0], options = _ref4[1];
      Style2.rule(selector, "transform", _this7.buildTranslate(options), width);
      if (!_this7.cssSlideHeight(options)) {
        Style2.rule(selector, "aspect-ratio", _this7.cssAspectRatio(options), width);
      }
    });
  };
  _proto3.registerSlideStyles = function registerSlideStyles() {
    var _this8 = this;
    var Style2 = this.Style;
    var selector = "." + CLASS_SLIDE;
    this.breakpoints.forEach(function(_ref5) {
      var width = _ref5[0], options = _ref5[1];
      Style2.rule(selector, "width", _this8.cssSlideWidth(options), width);
      Style2.rule(selector, "height", _this8.cssSlideHeight(options) || "100%", width);
      Style2.rule(selector, _this8.resolve("marginRight"), unit(options.gap) || "0px", width);
      Style2.rule(selector + " > img", "display", options.cover ? "none" : "inline", width);
    });
  };
  _proto3.buildTranslate = function buildTranslate(options) {
    var _this$Direction = this.Direction, resolve = _this$Direction.resolve, orient = _this$Direction.orient;
    var values = [];
    values.push(this.cssOffsetClones(options));
    values.push(this.cssOffsetGaps(options));
    if (this.isCenter(options)) {
      values.push(this.buildCssValue(orient(-50), "%"));
      values.push.apply(values, this.cssOffsetCenter(options));
    }
    return values.filter(Boolean).map(function(value) {
      return "translate" + resolve("X") + "(" + value + ")";
    }).join(" ");
  };
  _proto3.cssOffsetClones = function cssOffsetClones(options) {
    var _this$Direction2 = this.Direction, resolve = _this$Direction2.resolve, orient = _this$Direction2.orient;
    var cloneCount = this.getCloneCount();
    if (this.isFixedWidth(options)) {
      var _this$parseCssValue = this.parseCssValue(options[resolve("fixedWidth")]), value = _this$parseCssValue.value, unit2 = _this$parseCssValue.unit;
      return this.buildCssValue(orient(value) * cloneCount, unit2);
    }
    var percent = 100 * cloneCount / options.perPage;
    return orient(percent) + "%";
  };
  _proto3.cssOffsetCenter = function cssOffsetCenter(options) {
    var _this$Direction3 = this.Direction, resolve = _this$Direction3.resolve, orient = _this$Direction3.orient;
    if (this.isFixedWidth(options)) {
      var _this$parseCssValue2 = this.parseCssValue(options[resolve("fixedWidth")]), value = _this$parseCssValue2.value, unit2 = _this$parseCssValue2.unit;
      return [this.buildCssValue(orient(value / 2), unit2)];
    }
    var values = [];
    var perPage = options.perPage, gap = options.gap;
    values.push(orient(50 / perPage) + "%");
    if (gap) {
      var _this$parseCssValue3 = this.parseCssValue(gap), _value = _this$parseCssValue3.value, _unit = _this$parseCssValue3.unit;
      var gapOffset = (_value / perPage - _value) / 2;
      values.push(this.buildCssValue(orient(gapOffset), _unit));
    }
    return values;
  };
  _proto3.cssOffsetGaps = function cssOffsetGaps(options) {
    var cloneCount = this.getCloneCount();
    if (cloneCount && options.gap) {
      var orient = this.Direction.orient;
      var _this$parseCssValue4 = this.parseCssValue(options.gap), value = _this$parseCssValue4.value, unit2 = _this$parseCssValue4.unit;
      if (this.isFixedWidth(options)) {
        return this.buildCssValue(orient(value * cloneCount), unit2);
      }
      var perPage = options.perPage;
      var gaps = cloneCount / perPage;
      return this.buildCssValue(orient(gaps * value), unit2);
    }
    return "";
  };
  _proto3.resolve = function resolve(prop) {
    return camelToKebab(this.Direction.resolve(prop));
  };
  _proto3.cssPadding = function cssPadding(options, right) {
    var padding = options.padding;
    var prop = this.Direction.resolve(right ? "right" : "left", true);
    return padding && unit(padding[prop] || (isObject2(padding) ? 0 : padding)) || "0px";
  };
  _proto3.cssTrackHeight = function cssTrackHeight(options) {
    var height = "";
    if (this.isVertical()) {
      height = this.cssHeight(options);
      assert(height, '"height" is missing.');
      height = "calc(" + height + " - " + this.cssPadding(options, false) + " - " + this.cssPadding(options, true) + ")";
    }
    return height;
  };
  _proto3.cssHeight = function cssHeight(options) {
    return unit(options.height);
  };
  _proto3.cssSlideWidth = function cssSlideWidth(options) {
    return options.autoWidth ? "" : unit(options.fixedWidth) || (this.isVertical() ? "" : this.cssSlideSize(options));
  };
  _proto3.cssSlideHeight = function cssSlideHeight(options) {
    return unit(options.fixedHeight) || (this.isVertical() ? options.autoHeight ? "" : this.cssSlideSize(options) : this.cssHeight(options));
  };
  _proto3.cssSlideSize = function cssSlideSize(options) {
    var gap = unit(options.gap);
    return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
  };
  _proto3.cssAspectRatio = function cssAspectRatio(options) {
    var heightRatio = options.heightRatio;
    return heightRatio ? "" + 1 / heightRatio : "";
  };
  _proto3.buildCssValue = function buildCssValue(value, unit2) {
    return "" + value + unit2;
  };
  _proto3.parseCssValue = function parseCssValue(value) {
    if (isString(value)) {
      var number = parseFloat(value) || 0;
      var unit2 = value.replace(/\d*(\.\d*)?/, "") || "px";
      return {
        value: number,
        unit: unit2
      };
    }
    return {
      value,
      unit: "px"
    };
  };
  _proto3.parseBreakpoints = function parseBreakpoints() {
    var _this9 = this;
    var breakpoints = this.options.breakpoints;
    this.breakpoints.push(["default", this.options]);
    if (breakpoints) {
      forOwn2(breakpoints, function(options, width) {
        _this9.breakpoints.push([width, merge2(merge2({}, _this9.options), options)]);
      });
    }
  };
  _proto3.isFixedWidth = function isFixedWidth(options) {
    return !!options[this.Direction.resolve("fixedWidth")];
  };
  _proto3.isLoop = function isLoop() {
    return this.options.type === LOOP;
  };
  _proto3.isCenter = function isCenter(options) {
    if (options.focus === "center") {
      if (this.isLoop()) {
        return true;
      }
      if (this.options.type === SLIDE) {
        return !this.options.trimSpace;
      }
    }
    return false;
  };
  _proto3.isVertical = function isVertical() {
    return this.options.direction === TTB;
  };
  _proto3.buildClasses = function buildClasses() {
    var options = this.options;
    return [CLASS_ROOT, CLASS_ROOT + "--" + options.type, CLASS_ROOT + "--" + options.direction, options.drag && CLASS_ROOT + "--draggable", options.isNavigation && CLASS_ROOT + "--nav", CLASS_ACTIVE, !this.config.hidden && CLASS_RENDERED].filter(Boolean).join(" ");
  };
  _proto3.buildAttrs = function buildAttrs(attrs) {
    var attr = "";
    forOwn2(attrs, function(value, key) {
      attr += value ? " " + camelToKebab(key) + '="' + value + '"' : "";
    });
    return attr.trim();
  };
  _proto3.buildStyles = function buildStyles(styles) {
    var style2 = "";
    forOwn2(styles, function(value, key) {
      style2 += " " + camelToKebab(key) + ":" + value + ";";
    });
    return style2.trim();
  };
  _proto3.renderSlides = function renderSlides() {
    var _this10 = this;
    var tag = this.config.slideTag;
    return this.slides.map(function(content) {
      return "<" + tag + " " + _this10.buildAttrs(content.attrs) + ">" + (content.html || "") + "</" + tag + ">";
    }).join("");
  };
  _proto3.cover = function cover(content) {
    var styles = content.styles, _content$html = content.html, html = _content$html === void 0 ? "" : _content$html;
    if (this.options.cover && !this.options.lazyLoad) {
      var src = html.match(/<img.*?src\s*=\s*(['"])(.+?)\1.*?>/);
      if (src && src[2]) {
        styles.background = "center/cover no-repeat url('" + src[2] + "')";
      }
    }
  };
  _proto3.generateClones = function generateClones(contents) {
    var classes = this.options.classes;
    var count = this.getCloneCount();
    var slides = contents.slice();
    while (slides.length < count) {
      push(slides, slides);
    }
    push(slides.slice(-count).reverse(), slides.slice(0, count)).forEach(function(content, index) {
      var attrs = assign2({}, content.attrs, {
        class: content.attrs.class + " " + classes.clone
      });
      var clone = assign2({}, content, {
        attrs
      });
      index < count ? contents.unshift(clone) : contents.push(clone);
    });
  };
  _proto3.getCloneCount = function getCloneCount() {
    if (this.isLoop()) {
      var options = this.options;
      if (options.clones) {
        return options.clones;
      }
      var perPage = max.apply(void 0, this.breakpoints.map(function(_ref6) {
        var options2 = _ref6[1];
        return options2.perPage;
      }));
      return perPage * ((options.flickMaxPages || 1) + 1);
    }
    return 0;
  };
  _proto3.renderArrows = function renderArrows() {
    var html = "";
    html += '<div class="' + this.options.classes.arrows + '">';
    html += this.renderArrow(true);
    html += this.renderArrow(false);
    html += "</div>";
    return html;
  };
  _proto3.renderArrow = function renderArrow(prev) {
    var _this$options = this.options, classes = _this$options.classes, i18n = _this$options.i18n;
    var attrs = {
      class: classes.arrow + " " + (prev ? classes.prev : classes.next),
      type: "button",
      ariaLabel: prev ? i18n.prev : i18n.next
    };
    return "<button " + this.buildAttrs(attrs) + '><svg xmlns="' + XML_NAME_SPACE + '" viewBox="0 0 ' + SIZE + " " + SIZE + '" width="' + SIZE + '" height="' + SIZE + '"><path d="' + (this.options.arrowPath || PATH) + '" /></svg></button>';
  };
  _proto3.html = function html() {
    var _this$config = this.config, rootClass = _this$config.rootClass, listTag = _this$config.listTag, arrows = _this$config.arrows, beforeTrack = _this$config.beforeTrack, afterTrack = _this$config.afterTrack, slider = _this$config.slider, beforeSlider = _this$config.beforeSlider, afterSlider = _this$config.afterSlider;
    var html2 = "";
    html2 += '<div id="' + this.id + '" class="' + this.buildClasses() + " " + (rootClass || "") + '">';
    html2 += "<style>" + this.Style.build() + "</style>";
    if (slider) {
      html2 += beforeSlider || "";
      html2 += '<div class="splide__slider">';
    }
    html2 += beforeTrack || "";
    if (arrows) {
      html2 += this.renderArrows();
    }
    html2 += '<div class="splide__track">';
    html2 += "<" + listTag + ' class="splide__list">';
    html2 += this.renderSlides();
    html2 += "</" + listTag + ">";
    html2 += "</div>";
    html2 += afterTrack || "";
    if (slider) {
      html2 += "</div>";
      html2 += afterSlider || "";
    }
    html2 += "</div>";
    return html2;
  };
  return SplideRenderer2;
}();

// node_modules/@splidejs/svelte-splide/components/Splide/bind.js
var EVENTS_WITHOUT_ARGS = [
  EVENT_MOUNTED,
  EVENT_REFRESH,
  EVENT_RESIZE,
  EVENT_RESIZED,
  EVENT_DRAG,
  EVENT_DRAGGING,
  EVENT_DRAGGED,
  EVENT_SCROLL,
  EVENT_SCROLLED,
  EVENT_DESTROY,
  EVENT_AUTOPLAY_PLAY,
  EVENT_AUTOPLAY_PAUSE
];
function bind(splide, dispatchFn) {
  const dispatch = (event, detail = {}) => {
    dispatchFn(transform(event), { splide, ...detail });
  };
  splide.on(EVENT_CLICK, (Slide2, e) => {
    dispatch(EVENT_CLICK, { Slide: Slide2, e });
  });
  splide.on(EVENT_MOVE, (index, prev, dest) => {
    dispatch(EVENT_MOVE, { index, prev, dest });
  });
  splide.on(EVENT_MOVED, (index, prev, dest) => {
    dispatch(EVENT_MOVED, { index, prev, dest });
  });
  splide.on(EVENT_ACTIVE, (Slide2) => {
    dispatch(EVENT_ACTIVE, { Slide: Slide2 });
  });
  splide.on(EVENT_INACTIVE, (Slide2) => {
    dispatch(EVENT_INACTIVE, { Slide: Slide2 });
  });
  splide.on(EVENT_VISIBLE, (Slide2) => {
    dispatch(EVENT_VISIBLE, { Slide: Slide2 });
  });
  splide.on(EVENT_HIDDEN, (Slide2) => {
    dispatch(EVENT_HIDDEN, { Slide: Slide2 });
  });
  splide.on(EVENT_UPDATED, (options) => {
    dispatch(EVENT_UPDATED, options);
  });
  splide.on(EVENT_ARROWS_MOUNTED, (prev, next) => {
    dispatch(EVENT_ARROWS_MOUNTED, { prev, next });
  });
  splide.on(EVENT_ARROWS_UPDATED, (prev, next) => {
    dispatch(EVENT_ARROWS_UPDATED, { prev, next });
  });
  splide.on(EVENT_PAGINATION_MOUNTED, (data, item) => {
    dispatch(EVENT_PAGINATION_MOUNTED, { data, item });
  });
  splide.on(EVENT_PAGINATION_UPDATED, (data, prev, curr) => {
    dispatch(EVENT_PAGINATION_UPDATED, { data, prev, curr });
  });
  splide.on(EVENT_NAVIGATION_MOUNTED, (splides) => {
    dispatch(EVENT_NAVIGATION_MOUNTED, { splides });
  });
  splide.on(EVENT_AUTOPLAY_PLAYING, (rate) => {
    dispatch(EVENT_AUTOPLAY_PLAYING, { rate });
  });
  splide.on(EVENT_LAZYLOAD_LOADED, (img, Slide2) => {
    dispatch(EVENT_LAZYLOAD_LOADED, { img, Slide: Slide2 });
  });
  EVENTS_WITHOUT_ARGS.forEach((event) => {
    splide.on(event, () => {
      dispatch(event);
    });
  });
}
function transform(event) {
  return event.split(":").map((fragment, index) => {
    return index > 0 ? fragment.charAt(0).toUpperCase() + fragment.slice(1) : fragment;
  }).join("").replace("Lazyload", "LazyLoad");
}

// node_modules/@splidejs/svelte-splide/components/Splide/Splide.svelte
var file6 = "node_modules/@splidejs/svelte-splide/components/Splide/Splide.svelte";
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create2() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(102:2) { :else }",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let splidetrack;
  let current;
  splidetrack = new SplideTrack_default({
    props: {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(splidetrack.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(splidetrack, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const splidetrack_changes = {};
      if (dirty & /*$$scope*/
      8192) {
        splidetrack_changes.$$scope = { dirty, ctx: ctx2 };
      }
      splidetrack.$set(splidetrack_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(splidetrack.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(splidetrack.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(splidetrack, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(98:2) { #if hasTrack }",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create2() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(99:4) <SplideTrack>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*hasTrack*/
      ctx2[1]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    {
      class: div_class_value = classNames(
        "splide",
        /*className*/
        ctx[0]
      )
    },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create2() {
      div = element("div");
      if_block.c();
      set_attributes(div, div_data);
      add_location(div, file6, 92, 0, 2389);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[12](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className*/
        1 && div_class_value !== (div_class_value = classNames(
          "splide",
          /*className*/
          ctx2[0]
        ))) && { class: div_class_value },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      ctx[12](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "options", "splide", "extensions", "transition", "hasTrack", "go", "sync"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Splide", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  let { options = {} } = $$props;
  let { splide = void 0 } = $$props;
  let { extensions = void 0 } = $$props;
  let { transition = void 0 } = $$props;
  let { hasTrack = true } = $$props;
  const dispatch = createEventDispatcher();
  let root;
  let prevSlides;
  let prevOptions = merge({}, options);
  onMount(() => {
    $$invalidate(4, splide = new Splide(root, options));
    bind(splide, dispatch);
    splide.mount(extensions, transition);
    prevSlides = getSlides(splide);
    return () => splide.destroy();
  });
  afterUpdate(() => {
    if (splide) {
      const newSlides = getSlides(splide);
      if (!isEqualShallow(prevSlides, newSlides)) {
        splide.refresh();
        prevSlides = newSlides.slice();
      }
    }
  });
  function go(control) {
    splide == null ? void 0 : splide.go(control);
  }
  function sync(target) {
    splide == null ? void 0 : splide.sync(target);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      root = $$value;
      $$invalidate(2, root);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    if ("options" in $$new_props) $$invalidate(5, options = $$new_props.options);
    if ("splide" in $$new_props) $$invalidate(4, splide = $$new_props.splide);
    if ("extensions" in $$new_props) $$invalidate(6, extensions = $$new_props.extensions);
    if ("transition" in $$new_props) $$invalidate(7, transition = $$new_props.transition);
    if ("hasTrack" in $$new_props) $$invalidate(1, hasTrack = $$new_props.hasTrack);
    if ("$$scope" in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classNames,
    getSlides,
    isEqualDeep,
    isEqualShallow,
    merge,
    Splide,
    afterUpdate,
    createEventDispatcher,
    onMount,
    bind,
    SplideTrack: SplideTrack_default,
    className,
    options,
    splide,
    extensions,
    transition,
    hasTrack,
    dispatch,
    root,
    prevSlides,
    prevOptions,
    go,
    sync
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    if ("options" in $$props) $$invalidate(5, options = $$new_props.options);
    if ("splide" in $$props) $$invalidate(4, splide = $$new_props.splide);
    if ("extensions" in $$props) $$invalidate(6, extensions = $$new_props.extensions);
    if ("transition" in $$props) $$invalidate(7, transition = $$new_props.transition);
    if ("hasTrack" in $$props) $$invalidate(1, hasTrack = $$new_props.hasTrack);
    if ("root" in $$props) $$invalidate(2, root = $$new_props.root);
    if ("prevSlides" in $$props) prevSlides = $$new_props.prevSlides;
    if ("prevOptions" in $$props) $$invalidate(10, prevOptions = $$new_props.prevOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*splide, prevOptions, options*/
    1072) {
      $: if (splide && !isEqualDeep(prevOptions, options)) {
        $$invalidate(4, splide.options = options, splide);
        $$invalidate(10, prevOptions = merge({}, prevOptions));
      }
    }
  };
  return [
    className,
    hasTrack,
    root,
    $$restProps,
    splide,
    options,
    extensions,
    transition,
    go,
    sync,
    prevOptions,
    slots,
    div_binding,
    $$scope
  ];
}
var Splide_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      class: 0,
      options: 5,
      splide: 4,
      extensions: 6,
      transition: 7,
      hasTrack: 1,
      go: 8,
      sync: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Splide_1",
      options,
      id: create_fragment6.name
    });
  }
  get class() {
    return this.$$.ctx[0];
  }
  set class(className) {
    this.$$set({ class: className });
    flush();
  }
  get options() {
    return this.$$.ctx[5];
  }
  set options(options) {
    this.$$set({ options });
    flush();
  }
  get splide() {
    return this.$$.ctx[4];
  }
  set splide(splide) {
    this.$$set({ splide });
    flush();
  }
  get extensions() {
    return this.$$.ctx[6];
  }
  set extensions(extensions) {
    this.$$set({ extensions });
    flush();
  }
  get transition() {
    return this.$$.ctx[7];
  }
  set transition(transition) {
    this.$$set({ transition });
    flush();
  }
  get hasTrack() {
    return this.$$.ctx[1];
  }
  set hasTrack(hasTrack) {
    this.$$set({ hasTrack });
    flush();
  }
  get go() {
    return this.$$.ctx[8];
  }
  set go(value) {
    throw new Error("<Splide>: Cannot set read-only property 'go'");
  }
  get sync() {
    return this.$$.ctx[9];
  }
  set sync(value) {
    throw new Error("<Splide>: Cannot set read-only property 'sync'");
  }
};
var Splide_default = Splide_1;

// node_modules/@splidejs/svelte-splide/components/SplideTrack/SplideTrack.svelte
var file7 = "node_modules/@splidejs/svelte-splide/components/SplideTrack/SplideTrack.svelte";
function create_fragment7(ctx) {
  let div;
  let ul;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    {
      class: div_class_value = classNames(
        "splide__track",
        /*className*/
        ctx[0]
      )
    },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create2() {
      div = element("div");
      ul = element("ul");
      if (default_slot) default_slot.c();
      attr_dev(ul, "class", "splide__list");
      add_location(ul, file7, 6, 2, 204);
      set_attributes(div, div_data);
      add_location(div, file7, 5, 0, 125);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className*/
        1 && div_class_value !== (div_class_value = classNames(
          "splide__track",
          /*className*/
          ctx2[0]
        ))) && { class: div_class_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SplideTrack", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classNames, className });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [className, $$restProps, $$scope, slots];
}
var SplideTrack = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { class: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SplideTrack",
      options,
      id: create_fragment7.name
    });
  }
  get class() {
    throw new Error("<SplideTrack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SplideTrack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SplideTrack_default = SplideTrack;

// node_modules/@splidejs/svelte-splide/components/SplideSlide/SplideSlide.svelte
var file8 = "node_modules/@splidejs/svelte-splide/components/SplideSlide/SplideSlide.svelte";
function create_fragment8(ctx) {
  let li;
  let li_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let li_levels = [
    {
      class: li_class_value = classNames(
        "splide__slide",
        /*className*/
        ctx[0]
      )
    },
    /*$$restProps*/
    ctx[1]
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create2() {
      li = element("li");
      if (default_slot) default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file8, 5, 0, 125);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*className*/
        1 && li_class_value !== (li_class_value = classNames(
          "splide__slide",
          /*className*/
          ctx2[0]
        ))) && { class: li_class_value },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SplideSlide", slots, ["default"]);
  let { class: className = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classNames, className });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [className, $$restProps, $$scope, slots];
}
var SplideSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { class: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SplideSlide",
      options,
      id: create_fragment8.name
    });
  }
  get class() {
    throw new Error("<SplideSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SplideSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SplideSlide_default = SplideSlide;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Sliders/CardSlider.svelte
var file9 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Sliders/CardSlider.svelte";
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create2() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: '(11:4) <Splide aria-label=\\"Carousel\\" options={options}>',
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let link;
  let t;
  let div;
  let splide;
  let current;
  splide = new Splide_default({
    props: {
      "aria-label": "Carousel",
      options: (
        /*options*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      link = element("link");
      t = space();
      div = element("div");
      create_component(splide.$$.fragment);
      attr_dev(link, "rel", "stylesheet");
      attr_dev(link, "href", "https://cdn.jsdelivr.net/npm/@splidejs/splide@4.1.4/dist/css/splide.min.css");
      add_location(link, file9, 6, 4, 140);
      attr_dev(div, "class", "video-slider");
      add_location(div, file9, 9, 2, 269);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      append_dev(document.head, link);
      insert_dev(target, t, anchor);
      insert_dev(target, div, anchor);
      mount_component(splide, div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const splide_changes = {};
      if (dirty & /*options*/
      1) splide_changes.options = /*options*/
      ctx2[0];
      if (dirty & /*$$scope*/
      4) {
        splide_changes.$$scope = { dirty, ctx: ctx2 };
      }
      splide.$set(splide_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(splide.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(splide.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(div);
      }
      detach_dev(link);
      destroy_component(splide);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardSlider", slots, ["default"]);
  let { options = {} } = $$props;
  const writable_props = ["options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<CardSlider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2) $$invalidate(0, options = $$props2.options);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ Splide: Splide_default, SplideSlide: SplideSlide_default, options });
  $$self.$inject_state = ($$props2) => {
    if ("options" in $$props2) $$invalidate(0, options = $$props2.options);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [options, slots, $$scope];
}
var CardSlider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { options: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardSlider",
      options,
      id: create_fragment9.name
    });
  }
  get options() {
    throw new Error("<CardSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<CardSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardSlider_default = CardSlider;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Sliders/HighlightsSlider.svelte
var file10 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Sliders/HighlightsSlider.svelte";
function add_css2(target) {
  append_styles(target, "svelte-v2vfl9", ".video-slider-custom.svelte-v2vfl9  .splide__arrow{border-radius:0 !important;bottom:-60px !important;outline:none !important;border-radius:50% !important;display:flex !important;width:32px !important;height:32px !important;border-radius:16px;opacity:0.4;background:var(--Charcoal-700, #000000) !important}.video-slider-custom.svelte-v2vfl9 .splide__arrow--prev{left:auto !important;right:60px !important}.video-slider-custom.svelte-v2vfl9 .splide__arrow--next{right:15px !important}.video-slider-custom.svelte-v2vfl9 .splide__pagination{bottom:auto !important}.video-slider-custom.svelte-v2vfl9 .splide__arrow{z-index:2 !important}.video-slider-custom.svelte-v2vfl9 .splide__arrows{position:absolute;max-width:1920px;margin:0 auto;width:100%;bottom:-20px;left:50%;transform:translateX(-50%)}.video-slider-custom.svelte-v2vfl9 .splide__arrow svg{fill:#ffffff !important;width:20px !important;height:20px !important;color:#1D1D1D}@media(max-width: 992px){.video-slider-custom.svelte-v2vfl9 .splide__arrows{display:none !important}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSGlnaGxpZ2h0c1NsaWRlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBa0VRLG1EQUNJLDBCQUEyQixDQUUzQix1QkFBd0IsQ0FDeEIsdUJBQXdCLENBQ3hCLDRCQUE2QixDQUM3Qix1QkFBd0IsQ0FDeEIscUJBQXNCLENBQ3RCLHNCQUF1QixDQUN2QixrQkFBbUIsQ0FDbkIsV0FBWSxDQUNaLGtEQUNKLENBRUEsd0RBQ0ksb0JBQXFCLENBQ3JCLHFCQUNKLENBQ0Esd0RBQ0kscUJBQ0osQ0FFQSx1REFDSSxzQkFDSixDQUVBLGtEQUNJLG9CQUNKLENBRUEsbURBQ0ksaUJBQWtCLENBQ2xCLGdCQUFpQixDQUNqQixhQUFjLENBQ2QsVUFBVyxDQUNYLFlBQWEsQ0FDYixRQUFTLENBQ1QsMEJBQ0osQ0FFQSxzREFDSSx1QkFBdUIsQ0FDdkIscUJBQXNCLENBQ3RCLHNCQUF1QixDQUN2QixhQUNKLENBR0EseUJBQ0ksbURBQ0ksdUJBQ0osQ0FDSiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiSGlnaGxpZ2h0c1NsaWRlci5zdmVsdGUiXX0= */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_default_slot_1(ctx) {
  let div3;
  let div1;
  let img0;
  let img0_src_value;
  let t0;
  let div0;
  let img1;
  let img1_src_value;
  let t1;
  let div2;
  let p;
  let t3;
  const block = {
    c: function create2() {
      div3 = element("div");
      div1 = element("div");
      img0 = element("img");
      t0 = space();
      div0 = element("div");
      img1 = element("img");
      t1 = space();
      div2 = element("div");
      p = element("p");
      p.textContent = "Battlegrounds Mobile India Series of 2024 concludes in\n                        Hyderabad";
      t3 = space();
      attr_dev(img0, "alt", "");
      if (!src_url_equal(img0.src, img0_src_value = "/images/HeroThumbnail.png")) attr_dev(img0, "src", img0_src_value);
      attr_dev(img0, "loading", "lazy");
      attr_dev(img0, "class", "h-48 w-full flex-shrink-0 rounded-md object-cover object-center");
      add_location(img0, file10, 40, 24, 1933);
      if (!src_url_equal(img1.src, img1_src_value = "/images/PlayBTN.svg")) attr_dev(img1, "src", img1_src_value);
      attr_dev(img1, "alt", "play");
      attr_dev(img1, "class", "w-4 h-4");
      add_location(img1, file10, 46, 28, 2385);
      attr_dev(div0, "class", "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-14 h-14 bg-black/20 backdrop-blur rounded-full flex items-center justify-center");
      add_location(div0, file10, 45, 24, 2199);
      attr_dev(div1, "class", "relative");
      add_location(div1, file10, 39, 20, 1885);
      add_location(p, file10, 51, 22, 2654);
      attr_dev(div2, "class", "flex items-start self-stretch text-lg font-semibold leading-7 text-white");
      add_location(div2, file10, 50, 20, 2544);
      attr_dev(div3, "class", "flex flex-grow flex-col items-start justify-center gap-y-3 rounded-xl max-w-[238px] lg:max-w-[387px] transition duration-300 border border-transparent hover:border-[color:var(--Gold-800,#63542D)] bg-[var(--Charcoal-900,#111)]");
      add_location(div3, file10, 38, 16, 1625);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div1);
      append_dev(div1, img0);
      append_dev(div1, t0);
      append_dev(div1, div0);
      append_dev(div0, img1);
      append_dev(div3, t1);
      append_dev(div3, div2);
      append_dev(div2, p);
      insert_dev(target, t3, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
        detach_dev(t3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(38:12) <SplideSlide>",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let splideslide;
  let current;
  splideslide = new SplideSlide_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(splideslide.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(splideslide, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const splideslide_changes = {};
      if (dirty & /*$$scope*/
      32) {
        splideslide_changes.$$scope = { dirty, ctx: ctx2 };
      }
      splideslide.$set(splideslide_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(splideslide.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(splideslide.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(splideslide, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(37:8) {#each tournaments as tournament}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*tournaments*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create2() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(36:4) <CardSlider options={splideOptions}>",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let div2;
  let div1;
  let div0;
  let t1;
  let cardslider;
  let current;
  cardslider = new CardSlider_default({
    props: {
      options: (
        /*splideOptions*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "HIGHLIGHTS";
      t1 = space();
      create_component(cardslider.$$.fragment);
      attr_dev(div0, "class", "self-stretch h-6 text-amber-400 text-lg font-semibold font-['Inter'] uppercase leading-normal tracking-wide");
      add_location(div0, file10, 33, 8, 1346);
      attr_dev(div1, "class", "py-10 flex-col justify-center items-end gap-5 inline-flex");
      add_location(div1, file10, 32, 4, 1266);
      attr_dev(div2, "class", "video-slider-custom mb-16 svelte-v2vfl9");
      add_location(div2, file10, 31, 0, 1222);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      append_dev(div2, t1);
      mount_component(cardslider, div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const cardslider_changes = {};
      if (dirty & /*$$scope*/
      32) {
        cardslider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardslider.$set(cardslider_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(cardslider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cardslider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(cardslider);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HighlightsSlider", slots, []);
  const tournaments = [
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Summer Showdown",
      isInviteOnly: false,
      thumbnail: "../images/VideoThumb.png"
    }
  ];
  const splideOptions = {
    arrowPath: "",
    gap: "22px",
    autoplay: false,
    pagination: false,
    arrows: true,
    perMove: 1,
    focus: "left",
    autoWidth: true,
    type: "loop"
  };
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<HighlightsSlider> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    Splide: Splide_default,
    SplideSlide: SplideSlide_default,
    CardSlider: CardSlider_default,
    tournaments,
    splideOptions
  });
  return [tournaments, splideOptions];
}
var HighlightsSlider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {}, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HighlightsSlider",
      options,
      id: create_fragment10.name
    });
  }
};
var HighlightsSlider_default = HighlightsSlider;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/RegisterNowSection.svelte
var file11 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/RegisterNowSection.svelte";
function create_default_slot5(ctx) {
  let div3;
  let div0;
  let t1;
  let div1;
  let p;
  let t3;
  let div2;
  let a;
  const block = {
    c: function create2() {
      div3 = element("div");
      div0 = element("div");
      div0.textContent = "SAMPLE HEADING";
      t1 = space();
      div1 = element("div");
      p = element("p");
      p.textContent = "Blend your style and experience on a global, competitive stage.\n                You have 13 rounds to attack and defend your side using sharp\n                gunplay and tactical abilities.";
      t3 = space();
      div2 = element("div");
      a = element("a");
      a.textContent = "Register Now";
      attr_dev(div0, "class", "self-stretch text-4xl font-extrabold leading-10 text-yellow-400");
      add_location(div0, file11, 10, 12, 305);
      add_location(p, file11, 14, 14, 542);
      attr_dev(div1, "class", "flex items-start self-stretch text-sm leading-5 text-white max-w-lg");
      add_location(div1, file11, 13, 12, 445);
      attr_dev(a, "href", "");
      attr_dev(a, "class", "rounded-md bg-yellow-400 px-8 py-2 text-center leading-6 text-neutral-900 drop-shadow-lg");
      add_location(a, file11, 21, 14, 850);
      attr_dev(div2, "class", "flex items-end pt-4");
      add_location(div2, file11, 20, 12, 802);
      attr_dev(div3, "class", "relative z-0 flex flex-col items-start justify-center gap-y-3 py-24 font-medium");
      add_location(div3, file11, 9, 8, 198);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div0);
      append_dev(div3, t1);
      append_dev(div3, div1);
      append_dev(div1, p);
      append_dev(div3, t3);
      append_dev(div3, div2);
      append_dev(div2, a);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(9:4) <Section>",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let div;
  let section;
  let current;
  section = new Section_default({
    props: {
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      div = element("div");
      create_component(section.$$.fragment);
      attr_dev(div, "class", "bg-no-repeat bg-cover bg-center");
      set_style(div, "background-image", "url(../images/registernow-banner.png)");
      add_location(div, file11, 7, 0, 65);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(section, div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const section_changes = {};
      if (dirty & /*$$scope*/
      1) {
        section_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(section);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RegisterNowSection", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<RegisterNowSection> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ Section: Section_default });
  return [];
}
var RegisterNowSection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RegisterNowSection",
      options,
      id: create_fragment11.name
    });
  }
};
var RegisterNowSection_default = RegisterNowSection;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/ComingsoonBanner.svelte
var file12 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/ComingsoonBanner.svelte";
function create_fragment12(ctx) {
  let div0;
  let img0;
  let img0_src_value;
  let t0;
  let div23;
  let div22;
  let div1;
  let img1;
  let img1_src_value;
  let t1;
  let div21;
  let div8;
  let h20;
  let t3;
  let p0;
  let t5;
  let div7;
  let div2;
  let span0;
  let t7;
  let span1;
  let t9;
  let div3;
  let span2;
  let t11;
  let span3;
  let t13;
  let div4;
  let span4;
  let t15;
  let span5;
  let t17;
  let div5;
  let span6;
  let t19;
  let span7;
  let t21;
  let div6;
  let span8;
  let t23;
  let span9;
  let t25;
  let div20;
  let h21;
  let t27;
  let div19;
  let div11;
  let div9;
  let t28;
  let div10;
  let h30;
  let t30;
  let p1;
  let t32;
  let div15;
  let div13;
  let div12;
  let t33;
  let div14;
  let h31;
  let t35;
  let p2;
  let t37;
  let div18;
  let div16;
  let t38;
  let div17;
  let h32;
  let t40;
  let p3;
  const block = {
    c: function create2() {
      div0 = element("div");
      img0 = element("img");
      t0 = space();
      div23 = element("div");
      div22 = element("div");
      div1 = element("div");
      img1 = element("img");
      t1 = space();
      div21 = element("div");
      div8 = element("div");
      h20 = element("h2");
      h20.textContent = "ABOUT THIS TOURNAMENT";
      t3 = space();
      p0 = element("p");
      p0.textContent = "BATTLEGROUNDS MOBILE INDIA Pro Series 2024, the biggest esports event in India is back. The tournament will feature 128 invited teams, who will battle it out between 20th August to 29th September for the coveted championship title of BMPS 2024. With a total prize pool of 2 Crore INR at stake, who will emerge victorious?";
      t5 = space();
      div7 = element("div");
      div2 = element("div");
      span0 = element("span");
      span0.textContent = "Start Date:";
      t7 = space();
      span1 = element("span");
      span1.textContent = "20th August 2024";
      t9 = space();
      div3 = element("div");
      span2 = element("span");
      span2.textContent = "End Date:";
      t11 = space();
      span3 = element("span");
      span3.textContent = "29th September 2024";
      t13 = space();
      div4 = element("div");
      span4 = element("span");
      span4.textContent = "Total Teams:";
      t15 = space();
      span5 = element("span");
      span5.textContent = "128";
      t17 = space();
      div5 = element("div");
      span6 = element("span");
      span6.textContent = "Registration:";
      t19 = space();
      span7 = element("span");
      span7.textContent = "Invite only";
      t21 = space();
      div6 = element("div");
      span8 = element("span");
      span8.textContent = "Location:";
      t23 = space();
      span9 = element("span");
      span9.textContent = "To be announced";
      t25 = space();
      div20 = element("div");
      h21 = element("h2");
      h21.textContent = "IMPORTANT DATES";
      t27 = space();
      div19 = element("div");
      div11 = element("div");
      div9 = element("div");
      t28 = space();
      div10 = element("div");
      h30 = element("h3");
      h30.textContent = "Qualifier Rounds";
      t30 = space();
      p1 = element("p");
      p1.textContent = "20 Aug 2024 to 5 Aug 2024";
      t32 = space();
      div15 = element("div");
      div13 = element("div");
      div12 = element("div");
      t33 = space();
      div14 = element("div");
      h31 = element("h3");
      h31.textContent = "Semi Finals";
      t35 = space();
      p2 = element("p");
      p2.textContent = "20 Aug 2024 to 5 Aug 2024";
      t37 = space();
      div18 = element("div");
      div16 = element("div");
      t38 = space();
      div17 = element("div");
      h32 = element("h3");
      h32.textContent = "Grand Finals";
      t40 = space();
      p3 = element("p");
      p3.textContent = "20 Aug 2024 to 5 Aug 2024";
      if (!src_url_equal(img0.src, img0_src_value = "https://via.placeholder.com/378x184")) attr_dev(img0, "src", img0_src_value);
      attr_dev(img0, "alt", "small-screen banner");
      attr_dev(img0, "class", "w-full h-full object-cover ");
      add_location(img0, file12, 3, 4, 49);
      attr_dev(div0, "class", "lg:hidden w-full h-[184px]");
      add_location(div0, file12, 1, 0, 1);
      if (!src_url_equal(img1.src, img1_src_value = "/images/Coming Soon Section.png")) attr_dev(img1, "src", img1_src_value);
      attr_dev(img1, "alt", "");
      add_location(img1, file12, 11, 8, 538);
      attr_dev(div1, "class", "hidden lg:flex bg-black/20 rounded-xl justify-center items-center");
      add_location(div1, file12, 10, 6, 450);
      attr_dev(h20, "class", "text-amber-400 text-sm font-semibold font-['Inter'] uppercase leading-tight tracking-wide");
      add_location(h20, file12, 17, 10, 749);
      attr_dev(p0, "class", "text-[#b8b8b8] text-sm lg:text-base font-normal font-['Inter']");
      add_location(p0, file12, 18, 10, 888);
      attr_dev(span0, "class", "text-[#b8b8b8] text-sm lg:text-base font-medium");
      add_location(span0, file12, 25, 14, 1510);
      attr_dev(span1, "class", "text-white text-sm lg:text-base font-medium");
      add_location(span1, file12, 26, 14, 1605);
      attr_dev(div2, "class", "flex flex-row lg:flex-col gap-5 lg:gap-2");
      add_location(div2, file12, 24, 12, 1441);
      attr_dev(span2, "class", "text-[#b8b8b8] text-sm lg:text-base font-medium");
      add_location(span2, file12, 29, 14, 1787);
      attr_dev(span3, "class", "text-white text-sm lg:text-base font-medium");
      add_location(span3, file12, 30, 14, 1880);
      attr_dev(div3, "class", "flex flex-row lg:flex-col gap-5 lg:gap-2");
      add_location(div3, file12, 28, 12, 1718);
      attr_dev(span4, "class", "text-[#b8b8b8] text-sm lg:text-base font-medium");
      add_location(span4, file12, 33, 14, 2065);
      attr_dev(span5, "class", "text-white text-sm lg:text-base font-medium");
      add_location(span5, file12, 34, 14, 2161);
      attr_dev(div4, "class", "flex flex-row lg:flex-col gap-5 lg:gap-2");
      add_location(div4, file12, 32, 12, 1996);
      attr_dev(span6, "class", "text-[#b8b8b8] text-sm lg:text-base font-medium");
      add_location(span6, file12, 37, 14, 2330);
      attr_dev(span7, "class", "text-white text-sm lg:text-base font-medium");
      add_location(span7, file12, 38, 14, 2427);
      attr_dev(div5, "class", "flex flex-row lg:flex-col gap-5 lg:gap-2");
      add_location(div5, file12, 36, 12, 2261);
      attr_dev(span8, "class", "text-[#b8b8b8] text-sm lg:text-base font-medium");
      add_location(span8, file12, 41, 14, 2604);
      attr_dev(span9, "class", "text-white text-sm lg:text-base font-medium");
      add_location(span9, file12, 42, 14, 2697);
      attr_dev(div6, "class", "flex flex-row lg:flex-col gap-5 lg:gap-2");
      add_location(div6, file12, 40, 12, 2535);
      attr_dev(div7, "class", "flex flex-col gap-5 lg:flex-row lg:gap-10");
      add_location(div7, file12, 23, 10, 1373);
      attr_dev(div8, "class", "flex flex-col gap-3");
      add_location(div8, file12, 16, 8, 705);
      attr_dev(h21, "class", "text-amber-400 text-sm font-semibold font-['Inter'] uppercase leading-tight tracking-wide");
      add_location(h21, file12, 49, 10, 2923);
      attr_dev(div9, "class", "w-8 h-8 bg-amber-400 rounded-full");
      add_location(div9, file12, 53, 14, 3213);
      attr_dev(h30, "class", "text-white text-sm lg:text-base font-semibold");
      add_location(h30, file12, 55, 16, 3303);
      attr_dev(p1, "class", "text-[#888888] text-sm lg:text-base");
      add_location(p1, file12, 56, 16, 3399);
      add_location(div10, file12, 54, 14, 3281);
      attr_dev(div11, "class", "flex items-center gap-6");
      add_location(div11, file12, 52, 12, 3161);
      attr_dev(div12, "class", "w-4 h-4 bg-amber-400 rounded-full");
      add_location(div12, file12, 63, 16, 3737);
      attr_dev(div13, "class", "w-8 h-8 bg-[#111111] border-2 border-amber-400 rounded-full flex justify-center items-center");
      add_location(div13, file12, 62, 14, 3614);
      attr_dev(h31, "class", "text-amber-400 text-sm lg:text-base font-semibold");
      add_location(h31, file12, 66, 16, 3848);
      attr_dev(p2, "class", "text-[#888888] text-sm lg:text-base");
      add_location(p2, file12, 67, 16, 3943);
      add_location(div14, file12, 65, 14, 3826);
      attr_dev(div15, "class", "flex items-center gap-6");
      add_location(div15, file12, 61, 12, 3562);
      attr_dev(div16, "class", "w-8 h-8 bg-[#111111] border-2 border-[#313131] rounded-full");
      add_location(div16, file12, 73, 14, 4159);
      attr_dev(h32, "class", "text-[#b8b8b8] text-sm lg:text-base font-semibold");
      add_location(h32, file12, 75, 16, 4275);
      attr_dev(p3, "class", "text-[#888888] text-sm lg:text-base");
      add_location(p3, file12, 76, 16, 4371);
      add_location(div17, file12, 74, 14, 4253);
      attr_dev(div18, "class", "flex items-center gap-6");
      add_location(div18, file12, 72, 12, 4107);
      attr_dev(div19, "class", "flex flex-col gap-6 lg:flex-row lg:gap-4");
      add_location(div19, file12, 50, 10, 3056);
      attr_dev(div20, "class", "flex flex-col gap-3");
      add_location(div20, file12, 48, 8, 2879);
      attr_dev(div21, "class", "flex-1 flex flex-col gap-10");
      add_location(div21, file12, 14, 6, 609);
      attr_dev(div22, "class", "flex flex-col lg:flex-row gap-10 items-start lg:items-center lg:gap-7");
      add_location(div22, file12, 7, 4, 320);
      attr_dev(div23, "class", "bg-[#111111] px-6 pt-5 pb-10 flex flex-col gap-10 lg:px-10 lg:pt-10 lg:pb-16 lg:bg-Charcoal/900");
      add_location(div23, file12, 6, 2, 206);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div0, anchor);
      append_dev(div0, img0);
      insert_dev(target, t0, anchor);
      insert_dev(target, div23, anchor);
      append_dev(div23, div22);
      append_dev(div22, div1);
      append_dev(div1, img1);
      append_dev(div22, t1);
      append_dev(div22, div21);
      append_dev(div21, div8);
      append_dev(div8, h20);
      append_dev(div8, t3);
      append_dev(div8, p0);
      append_dev(div8, t5);
      append_dev(div8, div7);
      append_dev(div7, div2);
      append_dev(div2, span0);
      append_dev(div2, t7);
      append_dev(div2, span1);
      append_dev(div7, t9);
      append_dev(div7, div3);
      append_dev(div3, span2);
      append_dev(div3, t11);
      append_dev(div3, span3);
      append_dev(div7, t13);
      append_dev(div7, div4);
      append_dev(div4, span4);
      append_dev(div4, t15);
      append_dev(div4, span5);
      append_dev(div7, t17);
      append_dev(div7, div5);
      append_dev(div5, span6);
      append_dev(div5, t19);
      append_dev(div5, span7);
      append_dev(div7, t21);
      append_dev(div7, div6);
      append_dev(div6, span8);
      append_dev(div6, t23);
      append_dev(div6, span9);
      append_dev(div21, t25);
      append_dev(div21, div20);
      append_dev(div20, h21);
      append_dev(div20, t27);
      append_dev(div20, div19);
      append_dev(div19, div11);
      append_dev(div11, div9);
      append_dev(div11, t28);
      append_dev(div11, div10);
      append_dev(div10, h30);
      append_dev(div10, t30);
      append_dev(div10, p1);
      append_dev(div19, t32);
      append_dev(div19, div15);
      append_dev(div15, div13);
      append_dev(div13, div12);
      append_dev(div15, t33);
      append_dev(div15, div14);
      append_dev(div14, h31);
      append_dev(div14, t35);
      append_dev(div14, p2);
      append_dev(div19, t37);
      append_dev(div19, div18);
      append_dev(div18, div16);
      append_dev(div18, t38);
      append_dev(div18, div17);
      append_dev(div17, h32);
      append_dev(div17, t40);
      append_dev(div17, p3);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t0);
        detach_dev(div23);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComingsoonBanner", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ComingsoonBanner> was created with unknown prop '${key}'`);
  });
  return [];
}
var ComingsoonBanner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComingsoonBanner",
      options,
      id: create_fragment12.name
    });
  }
};
var ComingsoonBanner_default = ComingsoonBanner;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Pages/ActiveTournaments/OverView.svelte
var file13 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Pages/ActiveTournaments/OverView.svelte";
function create_default_slot_12(ctx) {
  let comingsoonbanner;
  let current;
  comingsoonbanner = new ComingsoonBanner_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(comingsoonbanner.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(comingsoonbanner, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(comingsoonbanner.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(comingsoonbanner.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(comingsoonbanner, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(10:4) <Section>",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let highlightsslider;
  let current;
  highlightsslider = new HighlightsSlider_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(highlightsslider.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(highlightsslider, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(highlightsslider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(highlightsslider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(highlightsslider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(16:4) <Section>",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let div;
  let section0;
  let t0;
  let prizepool;
  let t1;
  let section1;
  let t2;
  let registernowsection;
  let current;
  section0 = new Section_default({
    props: {
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  prizepool = new PrizePool_default({ $$inline: true });
  section1 = new Section_default({
    props: {
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  registernowsection = new RegisterNowSection_default({ $$inline: true });
  const block = {
    c: function create2() {
      div = element("div");
      create_component(section0.$$.fragment);
      t0 = space();
      create_component(prizepool.$$.fragment);
      t1 = space();
      create_component(section1.$$.fragment);
      t2 = space();
      create_component(registernowsection.$$.fragment);
      attr_dev(div, "class", "bg-Charcoal/900 py-10");
      add_location(div, file13, 8, 2, 388);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(section0, div, null);
      insert_dev(target, t0, anchor);
      mount_component(prizepool, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(section1, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(registernowsection, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const section0_changes = {};
      if (dirty & /*$$scope*/
      1) {
        section0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section0.$set(section0_changes);
      const section1_changes = {};
      if (dirty & /*$$scope*/
      1) {
        section1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section1.$set(section1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(section0.$$.fragment, local);
      transition_in(prizepool.$$.fragment, local);
      transition_in(section1.$$.fragment, local);
      transition_in(registernowsection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section0.$$.fragment, local);
      transition_out(prizepool.$$.fragment, local);
      transition_out(section1.$$.fragment, local);
      transition_out(registernowsection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
      destroy_component(section0);
      destroy_component(prizepool, detaching);
      destroy_component(section1, detaching);
      destroy_component(registernowsection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OverView", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<OverView> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    Section: Section_default,
    PrizePool: PrizePool_default,
    HighlightsSlider: HighlightsSlider_default,
    RegisterNowSection: RegisterNowSection_default,
    ComingsoonBanner: ComingsoonBanner_default
  });
  return [];
}
var OverView = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OverView",
      options,
      id: create_fragment13.name
    });
  }
};
var OverView_default = OverView;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Format.svelte
var file14 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Format.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_if_block2(ctx) {
  let div;
  const block = {
    c: function create2() {
      div = element("div");
      div.textContent = `${/*description*/
      ctx[6]}`;
      attr_dev(div, "class", "text-[#888888] text-sm font-medium mt-2");
      add_location(div, file14, 43, 12, 2323);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(43:10) {#if $openIndex === index}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let div2;
  let div1;
  let div0;
  let t1;
  let button;
  let svg;
  let path;
  let t2;
  let t3;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[4](
        /*index*/
        ctx[8],
        ...args
      )
    );
  }
  let if_block = (
    /*$openIndex*/
    ctx[0] === /*index*/
    ctx[8] && create_if_block2(ctx)
  );
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[5](
        /*index*/
        ctx[8]
      )
    );
  }
  const block = {
    c: function create2() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "WHAT IS ROUND 1?";
      t1 = space();
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      t2 = space();
      if (if_block) if_block.c();
      t3 = space();
      attr_dev(div0, "class", "grow text-[#888888] text-base font-semibold uppercase leading-normal tracking-tight");
      add_location(div0, file14, 30, 12, 1642);
      attr_dev(path, "d", "M5.22 8.22a.75.75 0 011.06 0L10 11.94l3.72-3.72a.75.75 0 111.06 1.06l-4.25 4.25a.75.75 0 01-1.06 0L5.22 9.28a.75.75 0 010-1.06z");
      attr_dev(path, "fill", "#888888");
      add_location(path, file14, 35, 16, 2006);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "fill", "none");
      add_location(svg, file14, 34, 14, 1914);
      attr_dev(button, "class", "w-5 h-5");
      add_location(button, file14, 33, 12, 1802);
      attr_dev(div1, "class", "flex justify-between items-center");
      add_location(div1, file14, 29, 10, 1582);
      attr_dev(div2, "class", "self-stretch px-6 py-5 bg-[#111111] rounded-md border border-[#313131] flex-col justify-start items-start gap-3");
      add_location(div2, file14, 27, 8, 1395);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      append_dev(div1, t1);
      append_dev(div1, button);
      append_dev(button, svg);
      append_dev(svg, path);
      append_dev(div2, t2);
      if (if_block) if_block.m(div2, null);
      append_dev(div2, t3);
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", click_handler, false, false, false, false),
          listen_dev(div2, "click", click_handler_1, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*$openIndex*/
        ctx[0] === /*index*/
        ctx[8]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block2(ctx);
          if_block.c();
          if_block.m(div2, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(25:6) {#each descriptions as description, index}",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*descriptions*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create2() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "w-full py-7 flex-col justify-start items-start gap-3 inline-flex");
      add_location(div, file14, 23, 4, 1127);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*toggleContent, descriptions, $openIndex*/
      13) {
        each_value = ensure_array_like_dev(
          /*descriptions*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(23:2) <Section>",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let section;
  let current;
  section = new Section_default({
    props: {
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(section.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const section_changes = {};
      if (dirty & /*$$scope, $openIndex*/
      513) {
        section_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let $openIndex;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Format", slots, []);
  let openIndex = writable(null);
  validate_store(openIndex, "openIndex");
  component_subscribe($$self, openIndex, (value) => $$invalidate(0, $openIndex = value));
  function toggleContent(index) {
    openIndex.update((current) => current === index ? null : index);
  }
  const descriptions = [
    "BATTLEGROUNDS MOBILE INDIA (BGMI) is an online multiplayer battle royale game developed and published by KRAFTON, INC for use on mobile phones.",
    "The game features various maps, weapons, and gameplay modes, providing a dynamic battle experience.",
    "Players can team up with friends, communicate in real-time, and strategize to win matches.",
    "Regular updates bring new features, events, and improvements, keeping the gameplay fresh and engaging.",
    "BGMI promotes responsible gaming and includes features to manage playtime and spending."
  ];
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Format> was created with unknown prop '${key}'`);
  });
  const click_handler = (index, event) => {
    event.stopPropagation();
    toggleContent(index);
  };
  const click_handler_1 = (index) => toggleContent(index);
  $$self.$capture_state = () => ({
    Section: Section_default,
    writable,
    openIndex,
    toggleContent,
    descriptions,
    $openIndex
  });
  $$self.$inject_state = ($$props2) => {
    if ("openIndex" in $$props2) $$invalidate(1, openIndex = $$props2.openIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $openIndex,
    openIndex,
    toggleContent,
    descriptions,
    click_handler,
    click_handler_1
  ];
}
var Format = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Format",
      options,
      id: create_fragment14.name
    });
  }
};
var Format_default = Format;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/General.svelte
var file15 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/General.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_if_block3(ctx) {
  let div;
  const block = {
    c: function create2() {
      div = element("div");
      div.textContent = `${/*description*/
      ctx[6]}`;
      attr_dev(div, "class", "text-[#888888] text-sm font-medium mt-2");
      add_location(div, file15, 43, 12, 2342);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(43:10) {#if $openIndex === index}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let div2;
  let div1;
  let div0;
  let t1;
  let button;
  let svg;
  let path;
  let t2;
  let t3;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[4](
        /*index*/
        ctx[8],
        ...args
      )
    );
  }
  let if_block = (
    /*$openIndex*/
    ctx[0] === /*index*/
    ctx[8] && create_if_block3(ctx)
  );
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[5](
        /*index*/
        ctx[8]
      )
    );
  }
  const block = {
    c: function create2() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "What is BATTLEGROUNDS MOBILE INDIA?";
      t1 = space();
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      t2 = space();
      if (if_block) if_block.c();
      t3 = space();
      attr_dev(div0, "class", "grow text-[#888888] text-base font-semibold uppercase leading-normal tracking-tight");
      add_location(div0, file15, 30, 12, 1642);
      attr_dev(path, "d", "M5.22 8.22a.75.75 0 011.06 0L10 11.94l3.72-3.72a.75.75 0 111.06 1.06l-4.25 4.25a.75.75 0 01-1.06 0L5.22 9.28a.75.75 0 010-1.06z");
      attr_dev(path, "fill", "#888888");
      add_location(path, file15, 35, 16, 2025);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "fill", "none");
      add_location(svg, file15, 34, 14, 1933);
      attr_dev(button, "class", "w-5 h-5");
      add_location(button, file15, 33, 12, 1821);
      attr_dev(div1, "class", "flex justify-between items-center");
      add_location(div1, file15, 29, 10, 1582);
      attr_dev(div2, "class", "self-stretch px-6 py-5 bg-[#111111] rounded-md border border-[#313131] flex-col justify-start items-start gap-3");
      add_location(div2, file15, 27, 8, 1395);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      append_dev(div1, t1);
      append_dev(div1, button);
      append_dev(button, svg);
      append_dev(svg, path);
      append_dev(div2, t2);
      if (if_block) if_block.m(div2, null);
      append_dev(div2, t3);
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", click_handler, false, false, false, false),
          listen_dev(div2, "click", click_handler_1, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*$openIndex*/
        ctx[0] === /*index*/
        ctx[8]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block3(ctx);
          if_block.c();
          if_block.m(div2, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(25:6) {#each descriptions as description, index}",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*descriptions*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create2() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "w-full py-7 flex-col justify-start items-start gap-3 inline-flex");
      add_location(div, file15, 23, 4, 1127);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*toggleContent, descriptions, $openIndex*/
      13) {
        each_value = ensure_array_like_dev(
          /*descriptions*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(23:2) <Section>",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let section;
  let current;
  section = new Section_default({
    props: {
      $$slots: { default: [create_default_slot8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(section.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const section_changes = {};
      if (dirty & /*$$scope, $openIndex*/
      513) {
        section_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let $openIndex;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("General", slots, []);
  let openIndex = writable(null);
  validate_store(openIndex, "openIndex");
  component_subscribe($$self, openIndex, (value) => $$invalidate(0, $openIndex = value));
  function toggleContent(index) {
    openIndex.update((current) => current === index ? null : index);
  }
  const descriptions = [
    "BATTLEGROUNDS MOBILE INDIA (BGMI) is an online multiplayer battle royale game developed and published by KRAFTON, INC for use on mobile phones.",
    "The game features various maps, weapons, and gameplay modes, providing a dynamic battle experience.",
    "Players can team up with friends, communicate in real-time, and strategize to win matches.",
    "Regular updates bring new features, events, and improvements, keeping the gameplay fresh and engaging.",
    "BGMI promotes responsible gaming and includes features to manage playtime and spending."
  ];
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<General> was created with unknown prop '${key}'`);
  });
  const click_handler = (index, event) => {
    event.stopPropagation();
    toggleContent(index);
  };
  const click_handler_1 = (index) => toggleContent(index);
  $$self.$capture_state = () => ({
    Section: Section_default,
    writable,
    openIndex,
    toggleContent,
    descriptions,
    $openIndex
  });
  $$self.$inject_state = ($$props2) => {
    if ("openIndex" in $$props2) $$invalidate(1, openIndex = $$props2.openIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $openIndex,
    openIndex,
    toggleContent,
    descriptions,
    click_handler,
    click_handler_1
  ];
}
var General = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "General",
      options,
      id: create_fragment15.name
    });
  }
};
var General_default = General;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/NavTabs/NavTab.svelte
var file16 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/NavTabs/NavTab.svelte";
function create_fragment16(ctx) {
  let div1;
  let div0;
  let nav;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create2() {
      div1 = element("div");
      div0 = element("div");
      nav = element("nav");
      if (default_slot) default_slot.c();
      attr_dev(nav, "class", "flex space-x-10 ");
      attr_dev(nav, "aria-label", "Tabs");
      add_location(nav, file16, 2, 6, 145);
      attr_dev(div0, "class", "border-b border-transparent");
      add_location(div0, file16, 1, 4, 97);
      attr_dev(div1, "class", "w-full flex justify-start items-center gap-3 md:gap-4 lg:gap-6 overflow-x-auto");
      add_location(div1, file16, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, nav);
      if (default_slot) {
        default_slot.m(nav, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavTab", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<NavTab> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var NavTab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavTab",
      options,
      id: create_fragment16.name
    });
  }
};
var NavTab_default = NavTab;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/NavTabs/TabLink.svelte
var file17 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/NavTabs/TabLink.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1yn4awz", ".tab-active{color:#FBBF24;border-bottom:2px solid #FBBF24}.disabled.svelte-1yn4awz{pointer-events:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFiTGluay5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUJFLFlBQ0UsYUFBYyxDQUNkLCtCQUNGLENBRUEseUJBQ0UsbUJBQ0YiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIlRhYkxpbmsuc3ZlbHRlIl19 */");
}
function create_fragment17(ctx) {
  let a;
  let active_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create2() {
      a = element("a");
      if (default_slot) default_slot.c();
      attr_dev(
        a,
        "href",
        /*link*/
        ctx[0]
      );
      attr_dev(a, "active-class", "tab-active");
      attr_dev(a, "class", "cursor-pointer px-3 py-2 text-xs text-Charcoal/100 md:py-3 md:text-sm lg:px-6 lg:py-4 lg:text-base font-semibold font-['Inter'] uppercase leading-tight tracking-tight border-b-2 border-transparent whitespace-nowrap svelte-1yn4awz");
      toggle_class(
        a,
        "disabled",
        /*disabled*/
        ctx[1]
      );
      add_location(a, file17, 6, 0, 105);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(active_action = Y.call(null, a)),
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*link*/
      1) {
        attr_dev(
          a,
          "href",
          /*link*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*disabled*/
      2) {
        toggle_class(
          a,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabLink", slots, ["default"]);
  let { link } = $$props;
  let { disabled = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (link === void 0 && !("link" in $$props || $$self.$$.bound[$$self.$$.props["link"]])) {
      console.warn("<TabLink> was created without expected prop 'link'");
    }
  });
  const writable_props = ["link", "disabled"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TabLink> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("link" in $$props2) $$invalidate(0, link = $$props2.link);
    if ("disabled" in $$props2) $$invalidate(1, disabled = $$props2.disabled);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ active: Y, link, disabled });
  $$self.$inject_state = ($$props2) => {
    if ("link" in $$props2) $$invalidate(0, link = $$props2.link);
    if ("disabled" in $$props2) $$invalidate(1, disabled = $$props2.disabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [link, disabled, $$scope, slots, click_handler];
}
var TabLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { link: 0, disabled: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabLink",
      options,
      id: create_fragment17.name
    });
  }
  get link() {
    throw new Error("<TabLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set link(value) {
    throw new Error("<TabLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TabLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TabLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabLink_default = TabLink;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Devider.svelte
var file18 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Devider.svelte";
function create_fragment18(ctx) {
  let div;
  const block = {
    c: function create2() {
      div = element("div");
      attr_dev(div, "class", "w-full border-t border-Charcoal/500");
      add_location(div, file18, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Devider", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Devider> was created with unknown prop '${key}'`);
  });
  return [];
}
var Devider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Devider",
      options,
      id: create_fragment18.name
    });
  }
};
var Devider_default = Devider;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Pages/ActiveTournaments/Support.svelte
function create_default_slot_6(ctx) {
  let t;
  const block = {
    c: function create2() {
      t = text("Support");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: '(17:8) <TabLink link=\\"/ActiveTournaments/Support/general\\" active={currentRoute === \\"/ActiveTournaments/Support/general\\"}>',
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let t;
  const block = {
    c: function create2() {
      t = text("Format");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: '(18:8) <TabLink link=\\"/ActiveTournaments/Support/format\\" active={currentRoute === \\"/ActiveTournaments/Support/format\\"}>',
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let tablink0;
  let t;
  let tablink1;
  let current;
  tablink0 = new TabLink_default({
    props: {
      link: "/ActiveTournaments/Support/general",
      active: (
        /*currentRoute*/
        ctx[0] === "/ActiveTournaments/Support/general"
      ),
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tablink1 = new TabLink_default({
    props: {
      link: "/ActiveTournaments/Support/format",
      active: (
        /*currentRoute*/
        ctx[0] === "/ActiveTournaments/Support/format"
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(tablink0.$$.fragment);
      t = space();
      create_component(tablink1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tablink0, target, anchor);
      insert_dev(target, t, anchor);
      mount_component(tablink1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablink0_changes = {};
      if (dirty & /*currentRoute*/
      1) tablink0_changes.active = /*currentRoute*/
      ctx2[0] === "/ActiveTournaments/Support/general";
      if (dirty & /*$$scope*/
      8) {
        tablink0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablink0.$set(tablink0_changes);
      const tablink1_changes = {};
      if (dirty & /*currentRoute*/
      1) tablink1_changes.active = /*currentRoute*/
      ctx2[0] === "/ActiveTournaments/Support/format";
      if (dirty & /*$$scope*/
      8) {
        tablink1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablink1.$set(tablink1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(tablink0.$$.fragment, local);
      transition_in(tablink1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablink0.$$.fragment, local);
      transition_out(tablink1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(tablink0, detaching);
      destroy_component(tablink1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(16:4) <NavTab>",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let navtab;
  let current;
  navtab = new NavTab_default({
    props: {
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(navtab.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(navtab, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navtab_changes = {};
      if (dirty & /*$$scope, currentRoute*/
      9) {
        navtab_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navtab.$set(navtab_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(navtab.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navtab.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navtab, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(15:2) <Section>",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let devider;
  let current;
  devider = new Devider_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(devider.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(devider, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(devider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(devider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(devider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(22:2) <Section>",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let general;
  let current;
  general = new General_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(general.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(general, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(general.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(general.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(general, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: '(31:0) <Route path=\\"/general\\">',
    ctx
  });
  return block;
}
function create_default_slot9(ctx) {
  let format2;
  let current;
  format2 = new Format_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(format2.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(format2, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(format2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(format2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(format2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: '(35:0) <Route path=\\"/format\\">',
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let section0;
  let t0;
  let section1;
  let t1;
  let route0;
  let t2;
  let route1;
  let t3;
  let route2;
  let current;
  section0 = new Section_default({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  section1 = new Section_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  route0 = new Route_default({
    props: {
      path: "",
      redirect: "/ActiveTournaments/Support/general"
    },
    $$inline: true
  });
  route1 = new Route_default({
    props: {
      path: "/general",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  route2 = new Route_default({
    props: {
      path: "/format",
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(section0.$$.fragment);
      t0 = space();
      create_component(section1.$$.fragment);
      t1 = space();
      create_component(route0.$$.fragment);
      t2 = space();
      create_component(route1.$$.fragment);
      t3 = space();
      create_component(route2.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(section0, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(section1, target, anchor);
      insert_dev(target, t1, anchor);
      mount_component(route0, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(route1, target, anchor);
      insert_dev(target, t3, anchor);
      mount_component(route2, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const section0_changes = {};
      if (dirty & /*$$scope, currentRoute*/
      9) {
        section0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section0.$set(section0_changes);
      const section1_changes = {};
      if (dirty & /*$$scope*/
      8) {
        section1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section1.$set(section1_changes);
      const route1_changes = {};
      if (dirty & /*$$scope*/
      8) {
        route1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      route1.$set(route1_changes);
      const route2_changes = {};
      if (dirty & /*$$scope*/
      8) {
        route2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      route2.$set(route2_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(section0.$$.fragment, local);
      transition_in(section1.$$.fragment, local);
      transition_in(route0.$$.fragment, local);
      transition_in(route1.$$.fragment, local);
      transition_in(route2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section0.$$.fragment, local);
      transition_out(section1.$$.fragment, local);
      transition_out(route0.$$.fragment, local);
      transition_out(route1.$$.fragment, local);
      transition_out(route2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
      }
      destroy_component(section0, detaching);
      destroy_component(section1, detaching);
      destroy_component(route0, detaching);
      destroy_component(route1, detaching);
      destroy_component(route2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let currentRoute;
  let $meta;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Support", slots, []);
  let meta = f.meta();
  validate_store(meta, "meta");
  component_subscribe($$self, meta, (value) => $$invalidate(2, $meta = value));
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Support> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    Format: Format_default,
    General: General_default,
    Route: Route_default,
    router: f,
    Section: Section_default,
    NavTab: NavTab_default,
    TabLink: TabLink_default,
    Devider: Devider_default,
    meta,
    currentRoute,
    $meta
  });
  $$self.$inject_state = ($$props2) => {
    if ("meta" in $$props2) $$invalidate(1, meta = $$props2.meta);
    if ("currentRoute" in $$props2) $$invalidate(0, currentRoute = $$props2.currentRoute);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$meta*/
    4) {
      $: $$invalidate(0, currentRoute = $meta.url);
    }
  };
  return [currentRoute, meta, $meta];
}
var Support = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Support",
      options,
      id: create_fragment19.name
    });
  }
};
var Support_default = Support;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Sliders/BannerSection.svelte
var file19 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Sliders/BannerSection.svelte";
function add_css4(target) {
  append_styles(target, "svelte-vpbher", ".splide__pagination__page{background-color:#B9B8B8 !important}.splide__pagination__page.is-active{background-color:#FFD700 !important}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFubmVyU2VjdGlvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBK0VJLDBCQUNFLG1DQUNGLENBR0Esb0NBQ0UsbUNBQ0YiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkJhbm5lclNlY3Rpb24uc3ZlbHRlIl19 */");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_default_slot_14(ctx) {
  let div10;
  let div9;
  let div8;
  let div7;
  let img0;
  let img0_src_value;
  let t0;
  let div1;
  let div0;
  let t2;
  let div3;
  let div2;
  let p;
  let t4;
  let div6;
  let div5;
  let a0;
  let img1;
  let img1_src_value;
  let t5;
  let div4;
  let t7;
  let a1;
  let t9;
  let button;
  let img2;
  let img2_src_value;
  let t10;
  const block = {
    c: function create2() {
      div10 = element("div");
      div9 = element("div");
      div8 = element("div");
      div7 = element("div");
      img0 = element("img");
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      div0.textContent = `${/*banner*/
      ctx[2].title}`;
      t2 = space();
      div3 = element("div");
      div2 = element("div");
      p = element("p");
      p.textContent = `${/*banner*/
      ctx[2].description}`;
      t4 = space();
      div6 = element("div");
      div5 = element("div");
      a0 = element("a");
      img1 = element("img");
      t5 = space();
      div4 = element("div");
      div4.textContent = `${/*banner*/
      ctx[2].button1.text}`;
      t7 = space();
      a1 = element("a");
      a1.textContent = `${/*banner*/
      ctx[2].button2.text}`;
      t9 = space();
      button = element("button");
      img2 = element("img");
      t10 = space();
      if (!src_url_equal(img0.src, img0_src_value = /*banner*/
      ctx[2].image)) attr_dev(img0, "src", img0_src_value);
      attr_dev(img0, "alt", "");
      attr_dev(img0, "class", "z-10 h-[120px] w-24 flex-shrink-0");
      add_location(img0, file19, 43, 16, 1565);
      attr_dev(div0, "class", "font-manrope flex-grow text-[56px] font-extrabold leading-[normal] text-yellow-400");
      add_location(div0, file19, 45, 18, 1707);
      attr_dev(div1, "class", "flex items-end pt-2");
      add_location(div1, file19, 44, 16, 1655);
      attr_dev(p, "class", "max-w-lg");
      add_location(p, file19, 51, 20, 2050);
      attr_dev(div2, "class", "flex flex-grow items-end text-lg leading-8 text-white");
      add_location(div2, file19, 50, 18, 1962);
      attr_dev(div3, "class", "flex items-end pt-1 w-full");
      add_location(div3, file19, 49, 16, 1903);
      attr_dev(img1, "alt", "");
      if (!src_url_equal(img1.src, img1_src_value = /*banner*/
      ctx[2].button1.icon)) attr_dev(img1, "src", img1_src_value);
      attr_dev(img1, "class", "h-4 w-4 flex-shrink-0");
      add_location(img1, file19, 57, 22, 2526);
      attr_dev(div4, "class", "text-[silver]");
      add_location(div4, file19, 58, 22, 2619);
      attr_dev(a0, "href", "");
      attr_dev(a0, "class", "flex items-center justify-center gap-x-3 rounded-md border border-solid border-neutral-600 bg-neutral-800 px-3 py-2 drop-shadow-lg");
      add_location(a0, file19, 56, 20, 2353);
      attr_dev(a1, "href", "");
      attr_dev(a1, "class", "rounded-md bg-yellow-400 px-3 py-2 text-center text-neutral-900 drop-shadow-lg");
      add_location(a1, file19, 60, 20, 2719);
      attr_dev(div5, "class", "flex flex-wrap items-center justify-center gap-x-6 gap-y-5 leading-6 ");
      add_location(div5, file19, 55, 18, 2249);
      attr_dev(img2, "alt", "");
      if (!src_url_equal(img2.src, img2_src_value = /*banner*/
      ctx[2].icon)) attr_dev(img2, "src", img2_src_value);
      attr_dev(img2, "class", "h-6 w-6 flex-shrink-0");
      add_location(img2, file19, 65, 20, 3106);
      attr_dev(button, "class", "flex h-12 w-12 flex-shrink-0 flex-col items-center absolute top-6 right-6 md:relative justify-center rounded-full bg-neutral-800 p-3 ml-3");
      add_location(button, file19, 64, 18, 2930);
      attr_dev(div6, "class", "flex flex-wrap items-end justify-between gap-x-6 gap-y-5 ");
      add_location(div6, file19, 54, 16, 2159);
      attr_dev(div7, "class", "z-0 flex flex-col justify-end gap-y-4 bg-cover bg-center pb-16 lg:pb-28 pt-[320px] lg:pt-[420px] w-f");
      add_location(div7, file19, 42, 14, 1434);
      attr_dev(div8, "class", "bg-image flex max-h-full max-w-full flex-col bg-no-repeat");
      add_location(div8, file19, 41, 12, 1348);
      attr_dev(div9, "class", "h-full w-full");
      add_location(div9, file19, 40, 10, 1308);
      attr_dev(div10, "class", "flex items-start w-full");
      add_location(div10, file19, 39, 8, 1260);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div10, anchor);
      append_dev(div10, div9);
      append_dev(div9, div8);
      append_dev(div8, div7);
      append_dev(div7, img0);
      append_dev(div7, t0);
      append_dev(div7, div1);
      append_dev(div1, div0);
      append_dev(div7, t2);
      append_dev(div7, div3);
      append_dev(div3, div2);
      append_dev(div2, p);
      append_dev(div7, t4);
      append_dev(div7, div6);
      append_dev(div6, div5);
      append_dev(div5, a0);
      append_dev(a0, img1);
      append_dev(a0, t5);
      append_dev(a0, div4);
      append_dev(div5, t7);
      append_dev(div5, a1);
      append_dev(div6, t9);
      append_dev(div6, button);
      append_dev(button, img2);
      insert_dev(target, t10, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div10);
        detach_dev(t10);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(39:6) <SplideSlide>",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let splideslide;
  let current;
  splideslide = new SplideSlide_default({
    props: {
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(splideslide.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(splideslide, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const splideslide_changes = {};
      if (dirty & /*$$scope*/
      32) {
        splideslide_changes.$$scope = { dirty, ctx: ctx2 };
      }
      splideslide.$set(splideslide_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(splideslide.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(splideslide.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(splideslide, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(38:4) {#each banners as banner}",
    ctx
  });
  return block;
}
function create_default_slot10(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*banners*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create2() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*banners*/
      2) {
        each_value = ensure_array_like_dev(
          /*banners*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(37:2) <CardSlider options={splideOptions}>",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let cardslider;
  let current;
  cardslider = new CardSlider_default({
    props: {
      options: (
        /*splideOptions*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot10] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(cardslider.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(cardslider, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const cardslider_changes = {};
      if (dirty & /*$$scope*/
      32) {
        cardslider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardslider.$set(cardslider_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(cardslider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cardslider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(cardslider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BannerSection", slots, []);
  const splideOptions = {
    arrowPath: "M24 8L21.18 10.82L32.34 22H8V26H32.34L21.18 37.18L24 40L40 24L24 8Z",
    gap: "2rem",
    pagination: true,
    autoplay: "pause",
    arrows: false,
    perPage: 1
  };
  const banners = [
    {
      title: "Winners Concluded",
      description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit...",
      image: "/images/Group-1116601973.svg",
      button1: {
        text: "Watch Live",
        icon: "/images/video-camera.svg"
      },
      button2: { text: "Tournament details" },
      icon: "/images/Union.svg"
    },
    {
      title: "BGIS 2024",
      description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit...",
      image: "/images/Group-1116601973.svg",
      button1: {
        text: "Watch Live",
        icon: "/images/video-camera.svg"
      },
      button2: { text: "Tournament details" },
      icon: "/images/Union.svg"
    }
  ];
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BannerSection> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    CardSlider: CardSlider_default,
    Splide: Splide_default,
    SplideSlide: SplideSlide_default,
    splideOptions,
    banners
  });
  return [splideOptions, banners];
}
var BannerSection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {}, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BannerSection",
      options,
      id: create_fragment20.name
    });
  }
};
var BannerSection_default = BannerSection;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Pages/ActiveTournaments/Videos.svelte
function create_default_slot_15(ctx) {
  let bannersection;
  let current;
  bannersection = new BannerSection_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(bannersection.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(bannersection, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(bannersection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bannersection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(bannersection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(7:0) <Section>",
    ctx
  });
  return block;
}
function create_default_slot11(ctx) {
  let highlightsslider;
  let current;
  highlightsslider = new HighlightsSlider_default({ $$inline: true });
  const block = {
    c: function create2() {
      create_component(highlightsslider.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(highlightsslider, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(highlightsslider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(highlightsslider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(highlightsslider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(11:0) <Section>",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let section0;
  let t;
  let section1;
  let current;
  section0 = new Section_default({
    props: {
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  section1 = new Section_default({
    props: {
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(section0.$$.fragment);
      t = space();
      create_component(section1.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(section0, target, anchor);
      insert_dev(target, t, anchor);
      mount_component(section1, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const section0_changes = {};
      if (dirty & /*$$scope*/
      1) {
        section0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section0.$set(section0_changes);
      const section1_changes = {};
      if (dirty & /*$$scope*/
      1) {
        section1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      section1.$set(section1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(section0.$$.fragment, local);
      transition_in(section1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section0.$$.fragment, local);
      transition_out(section1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(section0, detaching);
      destroy_component(section1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Videos", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Videos> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({ BannerSection: BannerSection_default, Section: Section_default, HighlightsSlider: HighlightsSlider_default });
  return [];
}
var Videos = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Videos",
      options,
      id: create_fragment21.name
    });
  }
};
var Videos_default = Videos;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Breadcrumb.svelte
var file20 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Breadcrumb.svelte";
function add_css5(target) {
  append_styles(target, "svelte-xb1zot", "\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnJlYWRjcnVtYi5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL1VzZXJzL3JhamVzaGF6bWVlcmEvd29ya3Mva3JhZnRvbi9VSS1LSVQtVEVTVC9ub2RlX21vZHVsZXMva2llLXVpLWtpdC9zcmMvY29tcG9uZW50cy9Ub3VybmFtZW50VGVtcGxhdGUvQ29tcG9uZW50cy9CcmVhZGNydW1iLnN2ZWx0ZSJdfQ== */");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  child_ctx[3] = i;
  return child_ctx;
}
function create_if_block4(ctx) {
  let div;
  let svg;
  let path;
  let t;
  const block = {
    c: function create2() {
      div = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      t = space();
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(path, "d", "M8.21967 5.21967C8.51256 4.92678 8.98744 4.92678 9.28033 5.21967L13.5303 9.46967C13.8232 9.76256 13.8232 10.2374 13.5303 10.5303L9.28033 14.7803C8.98744 15.0732 8.51256 15.0732 8.21967 14.7803C7.92678 14.4874 7.92678 14.0126 8.21967 13.7197L11.9393 10L8.21967 6.28033C7.92678 5.98744 7.92678 5.51256 8.21967 5.21967Z");
      attr_dev(path, "fill", "#888888");
      add_location(path, file20, 49, 14, 2025);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "fill", "none");
      add_location(svg, file20, 48, 12, 1915);
      attr_dev(div, "class", "w-5 h-5 flex-shrink-0 flex items-center");
      add_location(div, file20, 47, 10, 1849);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      append_dev(svg, path);
      append_dev(div, t);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(47:8) {#if index < items.length - 1}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let div;
  let a;
  let t0_value = (
    /*item*/
    ctx[1].text + ""
  );
  let t0;
  let a_href_value;
  let t1;
  let if_block_anchor;
  let if_block = (
    /*index*/
    ctx[3] < /*items*/
    ctx[0].length - 1 && create_if_block4(ctx)
  );
  const block = {
    c: function create2() {
      div = element("div");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      attr_dev(a, "href", a_href_value = /*item*/
      ctx[1].href);
      add_location(a, file20, 43, 10, 1739);
      attr_dev(div, "class", "text-sm");
      set_style(
        div,
        "color",
        /*index*/
        ctx[3] === /*items*/
        ctx[0].length - 1 ? "white" : "#888888"
      );
      add_location(div, file20, 42, 8, 1641);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, a);
      append_dev(a, t0);
      insert_dev(target, t1, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*items*/
      1 && t0_value !== (t0_value = /*item*/
      ctx2[1].text + "")) set_data_dev(t0, t0_value);
      if (dirty & /*items*/
      1 && a_href_value !== (a_href_value = /*item*/
      ctx2[1].href)) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & /*items*/
      1) {
        set_style(
          div,
          "color",
          /*index*/
          ctx2[3] === /*items*/
          ctx2[0].length - 1 ? "white" : "#888888"
        );
      }
      if (
        /*index*/
        ctx2[3] < /*items*/
        ctx2[0].length - 1
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t1);
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(42:6) {#each items as item, index}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let div0;
  let t0;
  let div2;
  let div1;
  let t1;
  let div3;
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const block = {
    c: function create2() {
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div3 = element("div");
      attr_dev(div0, "class", "w-full border-t border-Charcoal/500");
      add_location(div0, file20, 38, 2, 1406);
      attr_dev(div1, "class", "w-full py-3 bg-Charcoal/800 flex items-center gap-3");
      add_location(div1, file20, 40, 4, 1531);
      attr_dev(div2, "class", "mx-auto max-w-screen-2xl px-4 sm:px-6 lg:px-12");
      add_location(div2, file20, 39, 2, 1466);
      attr_dev(div3, "class", "w-full border-t border-Charcoal/500");
      add_location(div3, file20, 58, 2, 2527);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div0, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      insert_dev(target, t1, anchor);
      insert_dev(target, div3, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*items*/
      1) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t0);
        detach_dev(div2);
        detach_dev(t1);
        detach_dev(div3);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumb", slots, []);
  let { items = [] } = $$props;
  const writable_props = ["items"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Breadcrumb> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2) $$invalidate(0, items = $$props2.items);
  };
  $$self.$capture_state = () => ({ items });
  $$self.$inject_state = ($$props2) => {
    if ("items" in $$props2) $$invalidate(0, items = $$props2.items);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [items];
}
var Breadcrumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { items: 0 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumb",
      options,
      id: create_fragment22.name
    });
  }
  get items() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumb_default = Breadcrumb;

// node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Sliders/MediaSlider.svelte
var file21 = "node_modules/kie-ui-kit/src/components/TournamentTemplate/Components/Sliders/MediaSlider.svelte";
function add_css6(target) {
  append_styles(target, "svelte-v2vfl9", ".video-slider-custom.svelte-v2vfl9  .splide__arrow{border-radius:0 !important;bottom:-60px !important;outline:none !important;border-radius:50% !important;display:flex !important;width:32px !important;height:32px !important;border-radius:16px;opacity:0.4;background:var(--Charcoal-700, #000000) !important}.video-slider-custom.svelte-v2vfl9 .splide__arrow--prev{left:auto !important;right:60px !important}.video-slider-custom.svelte-v2vfl9 .splide__arrow--next{right:15px !important}.video-slider-custom.svelte-v2vfl9 .splide__pagination{bottom:auto !important}.video-slider-custom.svelte-v2vfl9 .splide__arrow{z-index:2 !important}.video-slider-custom.svelte-v2vfl9 .splide__arrows{position:absolute;max-width:1920px;margin:0 auto;width:100%;bottom:-20px;left:50%;transform:translateX(-50%)}.video-slider-custom.svelte-v2vfl9 .splide__arrow svg{fill:#ffffff !important;width:20px !important;height:20px !important;color:#1D1D1D}@media(max-width: 992px){.video-slider-custom.svelte-v2vfl9 .splide__arrows{display:none !important}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVkaWFTbGlkZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRFUSxtREFDSSwwQkFBMkIsQ0FFM0IsdUJBQXdCLENBQ3hCLHVCQUF3QixDQUN4Qiw0QkFBNkIsQ0FDN0IsdUJBQXdCLENBQ3hCLHFCQUFzQixDQUN0QixzQkFBdUIsQ0FDdkIsa0JBQW1CLENBQ25CLFdBQVksQ0FDWixrREFDSixDQUVBLHdEQUNJLG9CQUFxQixDQUNyQixxQkFDSixDQUNBLHdEQUNJLHFCQUNKLENBRUEsdURBQ0ksc0JBQ0osQ0FFQSxrREFDSSxvQkFDSixDQUVBLG1EQUNJLGlCQUFrQixDQUNsQixnQkFBaUIsQ0FDakIsYUFBYyxDQUNkLFVBQVcsQ0FDWCxZQUFhLENBQ2IsUUFBUyxDQUNULDBCQUNKLENBRUEsc0RBQ0ksdUJBQXVCLENBQ3ZCLHFCQUFzQixDQUN0QixzQkFBdUIsQ0FDdkIsYUFDSixDQUdBLHlCQUNJLG1EQUNJLHVCQUNKLENBQ0oiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIk1lZGlhU2xpZGVyLnN2ZWx0ZSJdfQ== */");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_default_slot_16(ctx) {
  let div9;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let p;
  let t2;
  let div7;
  let div3;
  let div1;
  let t4;
  let div2;
  let t6;
  let div6;
  let div4;
  let t8;
  let div5;
  let t10;
  let a;
  let div8;
  let t12;
  let svg;
  let path;
  let t13;
  const block = {
    c: function create2() {
      div9 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      p = element("p");
      p.textContent = "Battlegrounds Mobile India Series of 2024 concludes in\n                        Hyderabad";
      t2 = space();
      div7 = element("div");
      div3 = element("div");
      div1 = element("div");
      div1.textContent = "Source";
      t4 = space();
      div2 = element("div");
      div2.textContent = "The Hindu";
      t6 = space();
      div6 = element("div");
      div4 = element("div");
      div4.textContent = "Published";
      t8 = space();
      div5 = element("div");
      div5.textContent = "June 30, 2024";
      t10 = space();
      a = element("a");
      div8 = element("div");
      div8.textContent = "Read more";
      t12 = space();
      svg = svg_element("svg");
      path = svg_element("path");
      t13 = space();
      attr_dev(img, "alt", "");
      if (!src_url_equal(img.src, img_src_value = "/images/HeroThumbnail.png")) attr_dev(img, "src", img_src_value);
      attr_dev(img, "loading", "lazy");
      attr_dev(img, "class", "h-48 w-[363px] flex-shrink-0 rounded-md object-cover object-center");
      add_location(img, file21, 39, 20, 1910);
      add_location(p, file21, 45, 22, 2263);
      attr_dev(div0, "class", "flex items-start self-stretch text-lg font-semibold leading-7 text-white");
      add_location(div0, file21, 44, 20, 2153);
      attr_dev(div1, "class", "text-Charcoal/100");
      add_location(div1, file21, 52, 24, 2609);
      attr_dev(div2, "class", "font-medium text-white");
      add_location(div2, file21, 53, 24, 2678);
      add_location(div3, file21, 51, 22, 2579);
      attr_dev(div4, "class", "text-Charcoal/100");
      add_location(div4, file21, 56, 24, 2811);
      attr_dev(div5, "class", "font-medium text-white");
      add_location(div5, file21, 57, 24, 2883);
      add_location(div6, file21, 55, 22, 2781);
      attr_dev(div7, "class", "flex flex-wrap items-center gap-x-10 gap-y-5 text-sm leading-5 min-[1526px]:flex-nowrap");
      add_location(div7, file21, 50, 20, 2454);
      attr_dev(div8, "class", "text-sm leading-5 text-yellow-400");
      add_location(div8, file21, 61, 22, 3129);
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(path, "d", "M5.21967 14.7798C5.51256 15.0727 5.98744 15.0727 6.28033 14.7798L13.5 7.56017V13.2495C13.5 13.6637 13.8358 13.9995 14.25 13.9995C14.6642 13.9995 15 13.6637 15 13.2495V5.74951C15 5.3353 14.6642 4.99951 14.25 4.99951H6.75C6.33579 4.99951 6 5.3353 6 5.74951C6 6.16372 6.33579 6.49951 6.75 6.49951H12.4393L5.21967 13.7192C4.92678 14.0121 4.92678 14.4869 5.21967 14.7798Z");
      attr_dev(path, "fill", "#FBBF24");
      add_location(path, file21, 63, 24, 3334);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "fill", "none");
      add_location(svg, file21, 62, 22, 3214);
      attr_dev(a, "href", "");
      attr_dev(a, "class", "flex flex-wrap items-center gap-x-3 gap-y-2.5 min-[1526px]:flex-nowrap");
      add_location(a, file21, 60, 20, 3015);
      attr_dev(div9, "class", "flex flex-grow flex-col items-start justify-center gap-y-3 rounded-xl border border-solid border-Charcoal/600 p-5 max-w-[387px] transition-shadow duration-300 hover:shadow-[0px_6px_15px_0px_rgba(251,191,36,0.12)] hover:border-[color:var(--Gold-800,#63542D)]");
      add_location(div9, file21, 38, 16, 1617);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div9, anchor);
      append_dev(div9, img);
      append_dev(div9, t0);
      append_dev(div9, div0);
      append_dev(div0, p);
      append_dev(div9, t2);
      append_dev(div9, div7);
      append_dev(div7, div3);
      append_dev(div3, div1);
      append_dev(div3, t4);
      append_dev(div3, div2);
      append_dev(div7, t6);
      append_dev(div7, div6);
      append_dev(div6, div4);
      append_dev(div6, t8);
      append_dev(div6, div5);
      append_dev(div9, t10);
      append_dev(div9, a);
      append_dev(a, div8);
      append_dev(a, t12);
      append_dev(a, svg);
      append_dev(svg, path);
      insert_dev(target, t13, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div9);
        detach_dev(t13);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: "(38:12) <SplideSlide>",
    ctx
  });
  return block;
}
function create_each_block7(ctx) {
  let splideslide;
  let current;
  splideslide = new SplideSlide_default({
    props: {
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      create_component(splideslide.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(splideslide, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const splideslide_changes = {};
      if (dirty & /*$$scope*/
      32) {
        splideslide_changes.$$scope = { dirty, ctx: ctx2 };
      }
      splideslide.$set(splideslide_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(splideslide.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(splideslide.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(splideslide, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(37:8) {#each tournaments as tournament}",
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*tournaments*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const block = {
    c: function create2() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(36:4) <CardSlider options={splideOptions}>",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let div2;
  let div1;
  let div0;
  let t1;
  let cardslider;
  let current;
  cardslider = new CardSlider_default({
    props: {
      options: (
        /*splideOptions*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create2() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "Media";
      t1 = space();
      create_component(cardslider.$$.fragment);
      attr_dev(div0, "class", "flex-shrink-0 text-lg font-semibold uppercase leading-6 tracking-wider mb-5 ");
      add_location(div0, file21, 32, 8, 1377);
      attr_dev(div1, "class", "flex flex-wrap items-center justify-between gap-x-5 gap-y-2.5 self-stretch text-yellow-400");
      add_location(div1, file21, 31, 4, 1264);
      attr_dev(div2, "class", "video-slider-custom mb-16 svelte-v2vfl9");
      add_location(div2, file21, 30, 0, 1220);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      append_dev(div2, t1);
      mount_component(cardslider, div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const cardslider_changes = {};
      if (dirty & /*$$scope*/
      32) {
        cardslider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      cardslider.$set(cardslider_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(cardslider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cardslider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(cardslider);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MediaSlider", slots, []);
  const tournaments = [
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Spring Invitational",
      isInviteOnly: true,
      thumbnail: "../images/VideoThumb.png"
    },
    {
      name: "Summer Showdown",
      isInviteOnly: false,
      thumbnail: "../images/VideoThumb.png"
    }
  ];
  const splideOptions = {
    arrowPath: "",
    gap: "22px",
    autoplay: true,
    pagination: false,
    arrows: true,
    perMove: 1,
    focus: "left",
    autoWidth: true,
    type: "loop"
  };
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<MediaSlider> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    Splide: Splide_default,
    SplideSlide: SplideSlide_default,
    CardSlider: CardSlider_default,
    tournaments,
    splideOptions
  });
  return [tournaments, splideOptions];
}
var MediaSlider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {}, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MediaSlider",
      options,
      id: create_fragment23.name
    });
  }
};
var MediaSlider_default = MediaSlider;
export {
  BannerSection_default as BannerSection,
  Breadcrumb_default as Breadcrumb,
  CardSlider_default as CardSlider,
  ComingsoonBanner_default as ComingSoonBanner,
  Devider_default as Devider,
  Format_default as Format,
  General_default as General,
  HighlightsSlider_default as HightlightsSlider,
  LeaderBorad_default as Leaderboard,
  MediaSlider_default as MediaSlider,
  NavTab_default as NavTavb,
  OverView_default as OverView,
  RegisterNowSection_default as RegisterNowSection,
  Support_default as Support,
  TabLink_default as Tablink,
  test_default as Test,
  test1_default as Test1,
  Videos_default as Videos
};
/*! Bundled license information:

@splidejs/splide/dist/js/splide.esm.js:
  (*!
   * Splide.js
   * Version  : 4.1.4
   * License  : MIT
   * Copyright: 2022 Naotoshi Fujita
   *)
*/
//# sourceMappingURL=kie-ui-kit.js.map
