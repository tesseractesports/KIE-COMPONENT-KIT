import "./chunk-GYLHTBSF.js";
import {
  writable
} from "./chunk-I2CJVP44.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  check_outros,
  create_slot,
  detach_dev,
  dispatch_dev,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  hasContext,
  init,
  insert_dev,
  onMount,
  safe_not_equal,
  setContext,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-BLHMZ75E.js";
import "./chunk-U6FMO7UD.js";

// node_modules/tinro/dist/tinro_lib.js
function p(e, a = false) {
  return e = e.slice(e.startsWith("/#") ? 2 : 0, e.endsWith("/*") ? -2 : void 0), e.startsWith("/") || (e = "/" + e), e === "/" && (e = ""), a && !e.endsWith("/") && (e += "/"), e;
}
function d(e, a) {
  e = p(e, true), a = p(a, true);
  let r = [], n = {}, t = true, s = e.split("/").map((o) => o.startsWith(":") ? (r.push(o.slice(1)), "([^\\/]+)") : o).join("\\/"), c = a.match(new RegExp(`^${s}$`));
  return c || (t = false, c = a.match(new RegExp(`^${s}`))), c ? (r.forEach((o, h) => n[o] = c[h + 1]), { exact: t, params: n, part: c[0].slice(0, -1) }) : null;
}
function x(e, a, r) {
  if (r === "") return e;
  if (r[0] === "/") return r;
  let n = (c) => c.split("/").filter((o) => o !== ""), t = n(e), s = a ? n(a) : [];
  return "/" + s.map((c, o) => t[o]).join("/") + "/" + r;
}
function m(e, a, r, n) {
  let t = [a, "data-" + a].reduce((s, c) => {
    let o = e.getAttribute(c);
    return r && e.removeAttribute(c), o === null ? s : o;
  }, false);
  return !n && t === "" ? true : t || n || false;
}
function S(e) {
  let a = e.split("&").map((r) => r.split("=")).reduce((r, n) => {
    let t = n[0];
    if (!t) return r;
    let s = n.length > 1 ? n[n.length - 1] : true;
    return typeof s == "string" && s.includes(",") && (s = s.split(",")), r[t] === void 0 ? r[t] = [s] : r[t].push(s), r;
  }, {});
  return Object.entries(a).reduce((r, n) => (r[n[0]] = n[1].length > 1 ? n[1] : n[1][0], r), {});
}
function M(e) {
  return Object.entries(e).map(([a, r]) => r ? r === true ? a : `${a}=${Array.isArray(r) ? r.join(",") : r}` : null).filter((a) => a).join("&");
}
function w(e, a) {
  return e ? a + e : "";
}
function k(e) {
  throw new Error("[Tinro] " + e);
}
var i = { HISTORY: 1, HASH: 2, MEMORY: 3, OFF: 4, run(e, a, r, n) {
  return e === this.HISTORY ? a && a() : e === this.HASH ? r && r() : n && n();
}, getDefault() {
  return !window || window.location.pathname === "srcdoc" ? this.MEMORY : this.HISTORY;
} };
var y;
var $;
var H;
var b = "";
var l = E();
function E() {
  let e = i.getDefault(), a, r = (c) => window.onhashchange = window.onpopstate = y = null, n = (c) => a && a(R(e)), t = (c) => {
    c && (e = c), r(), e !== i.OFF && i.run(e, (o) => window.onpopstate = n, (o) => window.onhashchange = n) && n();
  }, s = (c) => {
    let o = Object.assign(R(e), c);
    return o.path + w(M(o.query), "?") + w(o.hash, "#");
  };
  return { mode: t, get: (c) => R(e), go(c, o) {
    _(e, c, o), n();
  }, start(c) {
    a = c, t();
  }, stop() {
    a = null, t(i.OFF);
  }, set(c) {
    this.go(s(c), !c.path);
  }, methods() {
    return j(this);
  }, base: (c) => b = c };
}
function _(e, a, r) {
  !r && ($ = H);
  let n = (t) => history[`${r ? "replace" : "push"}State`]({}, "", t);
  i.run(e, (t) => n(b + a), (t) => n(`#${a}`), (t) => y = a);
}
function R(e) {
  let a = window.location, r = i.run(e, (t) => (b ? a.pathname.replace(b, "") : a.pathname) + a.search + a.hash, (t) => String(a.hash.slice(1) || "/"), (t) => y || "/"), n = r.match(/^([^?#]+)(?:\?([^#]+))?(?:\#(.+))?$/);
  return H = r, { url: r, from: $, path: n[1] || "", query: S(n[2] || ""), hash: n[3] || "" };
}
function j(e) {
  let a = () => e.get().query, r = (c) => e.set({ query: c }), n = (c) => r(c(a())), t = () => e.get().hash, s = (c) => e.set({ hash: c });
  return { hash: { get: t, set: s, clear: () => s("") }, query: { replace: r, clear: () => r(""), get(c) {
    return c ? a()[c] : a();
  }, set(c, o) {
    n((h) => (h[c] = o, h));
  }, delete(c) {
    n((o) => (o[c] && delete o[c], o));
  } } };
}
var f = T();
function T() {
  let { subscribe: e } = writable(l.get(), (a) => {
    l.start(a);
    let r = P(l.go);
    return () => {
      l.stop(), r();
    };
  });
  return { subscribe: e, goto: l.go, params: Q, meta: O, useHashNavigation: (a) => l.mode(a ? i.HASH : i.HISTORY), mode: { hash: () => l.mode(i.HASH), history: () => l.mode(i.HISTORY), memory: () => l.mode(i.MEMORY) }, base: l.base, location: l.methods() };
}
function Y(e) {
  let a, r, n, t, s = () => {
    a = m(e, "href").replace(/^\/#|[?#].*$|\/$/g, ""), r = m(e, "exact", true), n = m(e, "active-class", true, "active");
  }, c = () => {
    let o = d(a, t);
    o && (o.exact && r || !r) ? e.classList.add(n) : e.classList.remove(n);
  };
  return s(), { destroy: f.subscribe((o) => {
    t = o.path, c();
  }), update: () => {
    s(), c();
  } };
}
function P(e) {
  let a = (r) => {
    let n = r.target.closest("a[href]"), t = n && m(n, "target", false, "_self"), s = n && m(n, "tinro-ignore"), c = r.ctrlKey || r.metaKey || r.altKey || r.shiftKey;
    if (t == "_self" && !s && !c && n) {
      let o = n.getAttribute("href").replace(/^\/#/, "");
      /^\/\/|^#|^[a-zA-Z]+:/.test(o) || (r.preventDefault(), e(o.startsWith("/") ? o : n.href.replace(window.location.origin, "")));
    }
  };
  return addEventListener("click", a), () => removeEventListener("click", a);
}
function Q() {
  return getContext("tinro").meta.params;
}
var g = "tinro";
var K = v({ pattern: "", matched: true });
function q(e) {
  let a = getContext(g) || K;
  (a.exact || a.fallback) && k(`${e.fallback ? "<Route fallback>" : `<Route path="${e.path}">`}  can't be inside ${a.fallback ? "<Route fallback>" : `<Route path="${a.path || "/"}"> with exact path`}`);
  let r = e.fallback ? "fallbacks" : "childs", n = writable({}), t = v({ fallback: e.fallback, parent: a, update(s) {
    t.exact = !s.path.endsWith("/*"), t.pattern = p(`${t.parent.pattern || ""}${s.path}`), t.redirect = s.redirect, t.firstmatch = s.firstmatch, t.breadcrumb = s.breadcrumb, t.match();
  }, register: () => (t.parent[r].add(t), async () => {
    t.parent[r].delete(t), t.parent.activeChilds.delete(t), t.router.un && t.router.un(), t.parent.match();
  }), show: () => {
    e.onShow(), !t.fallback && t.parent.activeChilds.add(t);
  }, hide: () => {
    e.onHide(), t.parent.activeChilds.delete(t);
  }, match: async () => {
    t.matched = false;
    let { path: s, url: c, from: o, query: h } = t.router.location, u = d(t.pattern, s);
    if (!t.fallback && u && t.redirect && (!t.exact || t.exact && u.exact)) {
      let A = x(s, t.parent.pattern, t.redirect);
      return f.goto(A, true);
    }
    t.meta = u && { from: o, url: c, query: h, match: u.part, pattern: t.pattern, breadcrumbs: t.parent.meta && t.parent.meta.breadcrumbs.slice() || [], params: u.params, subscribe: n.subscribe }, t.breadcrumb && t.meta && t.meta.breadcrumbs.push({ name: t.breadcrumb, path: u.part }), n.set(t.meta), u && !t.fallback && (!t.exact || t.exact && u.exact) && (!t.parent.firstmatch || !t.parent.matched) ? (e.onMeta(t.meta), t.parent.matched = true, t.show()) : t.hide(), u && t.showFallbacks();
  } });
  return setContext(g, t), onMount(() => t.register()), t;
}
function O() {
  return hasContext(g) ? getContext(g).meta : k("meta() function must be run inside any `<Route>` child component only");
}
function v(e) {
  let a = { router: {}, exact: false, pattern: null, meta: null, parent: null, fallback: false, redirect: false, firstmatch: false, breadcrumb: null, matched: false, childs: /* @__PURE__ */ new Set(), activeChilds: /* @__PURE__ */ new Set(), fallbacks: /* @__PURE__ */ new Set(), async showFallbacks() {
    if (!this.fallback && (await tick(), this.childs.size > 0 && this.activeChilds.size == 0 || this.childs.size == 0 && this.fallbacks.size > 0)) {
      let r = this;
      for (; r.fallbacks.size == 0; ) if (r = r.parent, !r) return;
      r && r.fallbacks.forEach((n) => {
        if (n.redirect) {
          let t = x("/", n.parent.pattern, n.redirect);
          f.goto(t, true);
        } else n.show();
      });
    }
  }, start() {
    this.router.un || (this.router.un = f.subscribe((r) => {
      this.router.location = r, this.pattern !== null && this.match();
    }));
  }, match() {
    this.showFallbacks();
  } };
  return Object.assign(a, e), a.start(), a;
}

// node_modules/tinro/cmp/Route.svelte
var get_default_slot_changes = (dirty) => ({
  params: dirty & /*params*/
  2,
  meta: dirty & /*meta*/
  4
});
var get_default_slot_context = (ctx) => ({
  params: (
    /*params*/
    ctx[1]
  ),
  meta: (
    /*meta*/
    ctx[2]
  )
});
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, params, meta*/
        262)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(33:0) {#if showContent}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*showContent*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*showContent*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*showContent*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Route", slots, ["default"]);
  let { path = "/*" } = $$props;
  let { fallback = false } = $$props;
  let { redirect = false } = $$props;
  let { firstmatch = false } = $$props;
  let { breadcrumb = null } = $$props;
  let showContent = false;
  let params = {};
  let meta = {};
  const route = q({
    fallback,
    onShow() {
      $$invalidate(0, showContent = true);
    },
    onHide() {
      $$invalidate(0, showContent = false);
    },
    onMeta(newmeta) {
      $$invalidate(2, meta = newmeta);
      $$invalidate(1, params = meta.params);
    }
  });
  const writable_props = ["path", "fallback", "redirect", "firstmatch", "breadcrumb"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Route> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2) $$invalidate(3, path = $$props2.path);
    if ("fallback" in $$props2) $$invalidate(4, fallback = $$props2.fallback);
    if ("redirect" in $$props2) $$invalidate(5, redirect = $$props2.redirect);
    if ("firstmatch" in $$props2) $$invalidate(6, firstmatch = $$props2.firstmatch);
    if ("breadcrumb" in $$props2) $$invalidate(7, breadcrumb = $$props2.breadcrumb);
    if ("$$scope" in $$props2) $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createRouteObject: q,
    path,
    fallback,
    redirect,
    firstmatch,
    breadcrumb,
    showContent,
    params,
    meta,
    route
  });
  $$self.$inject_state = ($$props2) => {
    if ("path" in $$props2) $$invalidate(3, path = $$props2.path);
    if ("fallback" in $$props2) $$invalidate(4, fallback = $$props2.fallback);
    if ("redirect" in $$props2) $$invalidate(5, redirect = $$props2.redirect);
    if ("firstmatch" in $$props2) $$invalidate(6, firstmatch = $$props2.firstmatch);
    if ("breadcrumb" in $$props2) $$invalidate(7, breadcrumb = $$props2.breadcrumb);
    if ("showContent" in $$props2) $$invalidate(0, showContent = $$props2.showContent);
    if ("params" in $$props2) $$invalidate(1, params = $$props2.params);
    if ("meta" in $$props2) $$invalidate(2, meta = $$props2.meta);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*path, redirect, firstmatch, breadcrumb*/
    232) {
      $: route.update({ path, redirect, firstmatch, breadcrumb });
    }
  };
  return [
    showContent,
    params,
    meta,
    path,
    fallback,
    redirect,
    firstmatch,
    breadcrumb,
    $$scope,
    slots
  ];
}
var Route = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      path: 3,
      fallback: 4,
      redirect: 5,
      firstmatch: 6,
      breadcrumb: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Route",
      options,
      id: create_fragment.name
    });
  }
  get path() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set path(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallback() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallback(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get redirect() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set redirect(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get firstmatch() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set firstmatch(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get breadcrumb() {
    throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set breadcrumb(value) {
    throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Route_default = Route;
export {
  Route_default as Route,
  Y as active,
  O as meta,
  f as router
};
//# sourceMappingURL=tinro.js.map
